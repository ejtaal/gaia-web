<!DOCTYPE html>
<html lang="en">
	<head>
		<title>GAIA-Web 3D Starfield v0.4</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="three.js/main.css">
		<style>
			body {
				background-color: #ccc;
				color: #000;
			}
			a {
				color: #f00;
			}
			#statusline {
				position: absolute;
                left: 0px;
                bottom: 0px;
				width: auto;
				height: auto;
				color: greenyellow;
				background-color: rgba(0,0,0,0.4);

				display: flex;
				flex-direction: row;
				justify-content: left;
				/* align-items: center; */

				text-align: left;
                margin: 0;
                padding: 5px;
                line-height: 100%;
				font-size: 12px;
				/* cursor: pointer; */
				border: 1px solid green;

			}
			#blocker {
				position: absolute;
				width: 100%;
				height: 100%;
				color: white;
				background-color: rgba(0,0,0,0.05);
			}

			#instructions {
				width: 100%;
				height: 100%;

				display: flex;
				flex-direction: column;
				justify-content: left;
				align-items: left;

                line-height: 100%;
				text-align: left;
				font-size: 12px;
                padding: 5px;
				cursor: pointer;
				border: 3px solid white;
			}			
		</style>
	</head>

	<body>
		<div id="blocker">
			<div id="instructions">
				<p style="font-size:16px">
<pre>



Welcome to Gaia-web, where you can fly through the 
stars like the USS Enterprise ðŸš€

Where pressing 'space' finally gets you into space ðŸ˜‰

Please be patient as star data is loaded in the background.

Click on the starfield to capture WASD keys to star moving around,
and ESC to uncapture and return the cursor.


</pre>
				</p>
				<p> Keyboard shortcuts: <br/>
					Move: WASDQE<br/>
					Warp: Space<br/>
					Look: Mouse<br/>
					Tour start/pause: T<br/>
					Tour next object: N<br/>
					Tour prev object: P<br/>
                    Back to Sol: B<br/>
                    aXis on/off: X<br>
                    Milky Way view: M (select a 10000+ ly dataset first)<br>
                    Pause data loading & rendering: Z<br>
                    sLow down starship: L<br>
                    Galactic overview: G<br/>
                    Right Mouse click: Zoom in/out<br>
				</p>
			</div>
		</div>
		<pre id="statusline"></pre>
		<!-- 
                    Planet Earth/Sol/Origin: P<br/>
                    Reload all star data for galactic overview: L<br/>
                    Reload all star data for Sol neighbourhood:Planet Earth/Sol/Origin: N<br/>
		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - trackball controls<br />
			MOVE mouse &amp; press LEFT/A: rotate, MIDDLE/S: zoom, RIGHT/D: pan
		</div>
			<script type="text/javascript" src="./stars-test-01.js"></script>
    		<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
		 -->
		
		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="./libs/es-module-shims.js"></script>
        <script src="./libs/tween.umd.js"></script>


		<script type="importmap">
			{
				"imports": {
					"three": "./three.js/build/three.module.js",
					"three/addons/": "./three.js/jsm/",
					"local-data/": "./data/"
				}
			}
		</script>
		<script type="x-shader/x-vertex" id="vertexshader">

			attribute float size;
			attribute vec3 customColor;

			varying vec3 vColor;

			void main() {

				vColor = customColor;

				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

				//gl_PointSize = size * ( 600.0 / -mvPosition.z );
				//gl_PointSize = size * ( 300.0 / -mvPosition.z);
                /*
                So there will exist some formulae that will mimic the appearance
                of nearby stars vs the cloudy appearance of a the myriad
                of milky way stars. Is it related to the size of rods
                in the eye?
                */
                /*
                // Attempt 1
                // Ok but milky way a bit overpowering
				gl_PointSize = size * pow(( 200.0 / -mvPosition.z), 1.3);
                if ( gl_PointSize < 4.0) gl_PointSize = 4.0;
                */

                /*
                // Attempt 2: The one to beat. Distant cloudy patches visible while
                // nearby stars are nice and bright
                // still dims out stars too quick i think where they
                // become brighter again once further in the distance?!
				
                gl_PointSize = size * pow(( 200.0 / -mvPosition.z), 1.5);
                // if ( (gl_PointSize > 1.0) && (gl_PointSize < 3.0)) gl_PointSize = 3.0;
                
                if ( gl_PointSize < 7.0) {
                    //vColor = vColor * (0.5 + gl_PointSize / 14.0);
                    //vColor = vColor * 0.9;
                    gl_PointSize = 3.5 + gl_PointSize / 2.0;
                }

                */
                /*
                // Attempt 
                // 
                
				gl_PointSize = size * pow(( 200.0 / -mvPosition.z), 1.3);
                if ( (gl_PointSize > 1.0) && (gl_PointSize < 3.0)) gl_PointSize = 3.0;
                if ( gl_PointSize < 1.0) gl_PointSize = 1.0;
                */

				// gl_PointSize = size * pow(( 200.0 / -mvPosition.z), 1.5);
				gl_PointSize = size * 500. / -mvPosition.z;
                // if ( (gl_PointSize > 1.0) && (gl_PointSize < 3.0)) gl_PointSize = 3.0;
                
                if ( gl_PointSize < (size * 3.)) {
                    //vColor = vColor * (0.5 + gl_PointSize / 14.0);
                    // dim but not too much
                    if ( gl_PointSize / 10. < 0.05) vColor = vColor * 0.05;
                    else vColor = vColor * gl_PointSize / 10.;

                    //gl_PointSize = size * 3.;
                    gl_PointSize = size * 3. * (1. - -mvPosition.z/20000.);
                }
                
                
                /*
                if ( gl_PointSize < 6.0) {
                    //vColor = vColor * (0.5 + gl_PointSize / 14.0);
                    //vColor = vColor * 0.9;
                    gl_PointSize = 3.0 + gl_PointSize / 2.0;
                }
                */

				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">

			uniform vec3 color;
			uniform sampler2D pointTexture;

			varying vec3 vColor;

			void main() {

				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );
                if ( gl_FragColor.a < 0.4 ) discard;

			}

		</script>
		<!-- The main index of all sky patch elements, which basically based on this file:
            http://cdn.gea.esac.esa.int/Gaia/gdr3/gaia_source/_MD5SUM.txt
         -->
         <script sync type="text/javascript" src="data/gaia-web-data-sets-index.js"></script>
         <script sync type="text/javascript" src="data/wp-open-clusters.js"></script>
         <script sync type="text/javascript" src="data/star-labels.js"></script>
         <script sync type="text/javascript" src="data/nebula-data.js"></script>

         
         <script type="module">
// Uhm yeah the HTML ain't gonna dictate our indentation. Who does it think it is!?!?
import * as THREE from 'three';
// THREE.Object3D.DefaultUp.set(0, 0, 1);

import Stats from 'three/addons/libs/stats.module.js';
import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
import { FontLoader } from 'three/addons/loaders/FontLoader.js';

// import { TrackballControls } from 'three/addons/controls/TrackballControls.js';

import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

// Courtesy of: https://codepen.io/hootstheowl/pen/xOQVQg
// class CubeWebGL {
//   constructor(props = {}) {
//     Object.assign(this, {
//       // set variable settings
//       container: props.container || document.body,
//       fps: props.fps || 30,
//       theta: props.theta || 0.1,
//       radius: props.radius || 600,
//       opacity: props.opacity || 0.2,
//       count: props.count || 150,
//       palette: props.palette || null,
//       // containers for ThreeJS animation
//       then: Date.now(),
//       camera: null,
//       scene: null,
//       renderer: null,
//     });
//     // // let's go!
//     // this.init();
//     // this.animate();
//     // document.addEventListener(
//     //   'mousedown', this.getIntersect.bind(this), false
//     // );
//   }
//   getIntersect(e) {
//     const raycaster = new THREE.Raycaster();
//     const mouse = new THREE.Vector3();
//     mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
// 	  mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
//     // update the picking ray with the camera and mouse position	
// 	  raycaster.setFromCamera( mouse, this.camera );	
//     // calculate objects intersecting the picking ray
//     const intersects = raycaster.intersectObjects( this.scene.children );
//     console.log(intersects)
//   }
//   addCube() {
//     const { palette, opacity } = this;
//     if (Array.isArray(palette)) {
//       const cubeColor = palette[Math.floor(
//         Math.random() * palette.length
//       )];
//     }
//     const cube = new THREE.Mesh(
//       new THREE.BoxGeometry(2.5, 2.5, 2.5),
//       new THREE.MeshBasicMaterial({
//         color: Math.random() * 0x808008 + 0x808080,
//         transparent: true,
//         opacity,
//       })
//     );
//     cube.position.x = this.generatePosition();
//     cube.position.y = this.generatePosition();
//     cube.position.z = this.generatePosition();
//     cube.scale.x= cube.scale.y = cube.scale.z = Math.random() * 45;
//     this.scene.add(cube);
//   }



// var menu = {
//     data_set = 'star_density': '',
//     prev_data_set = 'star_density',
//   vely: 0,
//   camera: {
//     speed: 0.0001
//   },
//   stop: function() {
//     this.velx = 0;
//     this.vely = 0;
//   },
//   reset: function() {
//     this.velx = 0.1;
//     this.vely = 0.1;
//     camera.position.z = 75;
//     camera.position.x = 0;
//     camera.position.y = 0;
//     cube.scale.x = 1;
//     cube.scale.y = 1;
//     cube.scale.z = 1;
//     cube.material.wireframe = true;
//   }
// };


let data_set = 'px80_2000ly_15mag'
let prev_data_set = data_set
// let prev_data_set = 'star_density'
let data_set_type = ''
let data_set_xyz_multiplier = 100

let moveForward = false;
let moveBackward = false;
let moveLeft = false;
let moveRight = false;
let moveUp = false;
let moveDown = false;
let canJump = false;
let warp_speed = 1;
let warp_enabled = false;
let global_sizeAttenuation = true;
let global_sizeAttenuation_multiplier = 1;
let axes_added = false;
let default_camera_fov = 60

let DEG2RAD = Math.PI / 180

let global_render_load_pause = false;

let axesHelper = new THREE.AxesHelper( 100 );
let we_want_axes = true;

let slow_down_cowboy = false;

let earth_hyades_milkyway_bg = icrs_to_threejs( [101, 160, 62])


let stars_filter = 'da_hood';
// let stars_filter = 'galactic';
let prev_stars_filter = ''; // Set to empty to force reload @ reload_all_stars() call

let tour_active = false;
let tour_speed = 0;
let tour_target_arrived = false;
let tour_time_at_target = 0;
let tour_prev_update = 0;
let tour_orbit_radius_default = 25; //ly
let old_tour_targets = [
    /*
    [  62, 130, 50, 'Hyades'],
    [ 222, 336, 178, 'Messier 45, Pleiades'],
    [ -366, 434, 203, 'Messier 44, Beehive Cluster'],
    [ -213, 438, -385, 'NGC 2451 A'],
    [ -200, 68, -442, 'IC 2602, Southern Pleiades'],
    [ -18.6,-746.4,-517.6, 'Messier 7'],
    [ 125, 1219, -130, 'Trapezium Cluster?'],
    [ 135, 1260, -115, 'Trapezium Cluster 2?'],    
    [ 489, 730,  553, 'IC 348'], // <- is this really something?
    [ -784, 194, -1333, 'NGC 3532, Wishing Well Cluster '],
    [ -108, -1263, -800, 'Messier 6, Butterfly Cluster'],
    [ 907, 779, 1102, 'Messier 34'],
    [ -2176.2, -4843.8, -2653.4, 'Messier 4' ],
    */
    [ -406, 838, -731, 'NGC 2451 B'],
    //    [ , , , ''],
    [ 515, 340, 1055, '?'],

    
    [ 144.4, 1113.5, 53.8, '?'],
    [ -266.2, 1239.2,1100.6, '?' ],
    [ 260, -1525, 148, '?' ],
    [ -628, -1429, -1341, '?' ],

    [ 3618.0, 2559.1, 6839.6, 'NGC 884 / NGC 869' ],
    [ 141, 4179, 2670, 'Messier 37'],
    [ 3792, -40, 5780, 'NGC 7789, White Rose Cluster'],
    [ -302, -1940, -2330, 'IC 4651'],
    [ -1710, 3209, -2895, 'Behind NGC 2451 A/B?'],
    [ -1875, 2023, 576, 'Messier 67'],
    [ 407, 2954, 2144, 'Messier 38'],
    /*
    [ , , , ''],
    [ , , , ''],
    [ , , , ''],
    [ , , , ''],
    [ ], 
    */
    ];

let tour_targets = wp_open_clusters

let label_font;
let labels_loaded = false;
let label_meshes = [];

let tour_orbit_angle = 0;
let tour_orbit_dec = 0;
let tour_orbit_start_x;
let tour_orbit_start_y;
let tour_orbit_start_z;
let tour_orbit_insertion_distance;
let tour_orbit_insertion_speed;
let tour_orbit_target;
let tour_started = false;
let tour_stops = [];
let tour_target_index = 0;
let tour_busy = false;
let tour_object_panning = true;
let tour_name = 'open clusters';
let tour_target_name = '';
let stop_tween = false;

let clock = new THREE.Clock();
let delta = 0;
// 60 fps
let interval = 1 / 60;

// let tour_target_name = '';

let prevTime = performance.now();
const velocity = new THREE.Vector3();
const direction = new THREE.Vector3();
const vertex = new THREE.Vector3();
const camera_vector = new THREE.Vector3();
const color = new THREE.Color();
let initial_scene_reloaded = false;

var spinner = ['-', '\\', '|', '/']
let statusline = 'Data being loaded, please wait...'
let available_elements = []
for (var i = 0; i < 100; i++) available_elements.push( i);


const sprite = new THREE.TextureLoader().load( 'three.js/textures/sprites/disc.png' );

let camera, perspectiveCamera, orthographicCamera, controls, scene, renderer, stats;

const params = {
    orthographicCamera: false,
    'option 1': false,
    'option 2': true
};

const frustumSize = 400;
var star_max_dist = 10**5;
var star_max_dist = 10**3;
var all_stars = {};
var rendered_sky_elements = [];
var total_stars_in_scene = 0;
var total_cubes_in_scene = 0;

var loading_lock = false;

var speed = 0
var speed_multiplier = 10.0	// 5.0
var lightyear_p_parsec = 3.261563777

init();
animate();

function icrs_to_threejs( c, reverse = false) {
    /*
    Three.js and other GL implementations use a convention of
    Y = up, Z = back/forward
    While ICRS cartesian would be:
    Z = up, X = back/forward
    Hence we need to transform ICRS <-> Three.js coords throughout.
    What fun and opportunity for bugs to creep in, groan :'(
        
    Further info:
    https://gkjohnson.github.io/threejs-sandbox/basis-transform/

      Z    
      |    
      |    
      .----- Y
     /     
   X       
   
   Needs to become and vice verse:        
      Y    
      |    
      |    
      .----- X
     /     
   Z       


    */
    
    var transposed = []
    if (reverse) transposed = [ c[2], c[0], c[1] ];
    else         transposed = [ c[1], c[2], c[0] ];
    // console.log( c, transposed)
    return transposed;



}

function add_nebulae_to_scene( scene, nebulae_data) {
    // console.log('Entering nebulae....')
    statusline = 'Loading nebulae into scene...'
    // return 0

    var nebula_targets = []

    var method = 2
    if (method == 2) {
        // console.log('brick wall')

        // MeshPhongMaterial needs light, else it will be black
        // scene.add(new THREE.AmbientLight(0xAAAAAA))
        scene.add(new THREE.AmbientLight(0xFFFFFF))

        var ni = 0;
        for ( ni = 0; ni < nebulae_data.length; ni++) {
            var n = nebulae_data[ni]
            var x = n[0]
            var y = n[1]
            var z = n[2]
            var name = n[3]
            var size = n[4]
            var rotation = n[5]
            var dirname = n[6]
            nebula_targets.push( [x, y, z, name, size])

            // let neb_map = new THREE.TextureLoader().load(`nebulae/${dirname}/in.jpg`);
            let neb_map = new THREE.TextureLoader().load(`nebulae/${dirname}/out.jpg`);


            let neb_dmap = new THREE.TextureLoader().load(`nebulae/${dirname}/dmap.jpg`);
            let neb_amap = new THREE.TextureLoader().load(`nebulae/${dirname}/amap.jpg`);
            let neb_bmap = new THREE.TextureLoader().load(`nebulae/${dirname}/bmap.jpg`);

            var displacement_opacity_array = [
                // [ 25, -1, 0.1, neb_bmap ],
                // [ 15, -2, 0.5, neb_bmap ],
                // // [ 10, -2, 0.5, neb_bmap ],
                // [ 5, -2, 0.2, neb_bmap ],
                [ 0, 0, 1, neb_bmap],
                [ -25 * size / 100, 1, 1, neb_map ],
                [ 25 * size / 100, -1, 1, neb_map ],
                // [ -25, 1, 0.2 ],
                // [ -15, 2, 0.1 ],
            ]

            for (var di = 0; di < displacement_opacity_array.length; di++) {
                var d = displacement_opacity_array[di]
            // for (var di = 0; di < 100; di++) {
            //     var d = [
            //         100 - di, 0, di / 100, neb_map
            //     ]
                let neb_material = new THREE.MeshPhongMaterial({
                    // color: 0xffff00, 
                    side: THREE.DoubleSide,
                    // bumpMap: bmap,
                    // bumpScale: 1.3,
                    displacementMap: neb_dmap,
                    displacementScale: d[0],
                    displacementBias: d[1],
                    opacity: d[2],
                    map: d[3],
                    transparent: true,
                    // shading: THREE.SmoothShading,
                    alphaMap: neb_amap,
                    depthTest: false,
                    // alphaTest: 0.05,
                    reflectivity: 0,
                });
                // console.log( neb_map.naturalWidth, neb_map.naturalHeight );

                const neb_geometry = new THREE.PlaneGeometry( size, size, 1000, 1000 );
                const neb_plane = new THREE.Mesh( neb_geometry, neb_material );
                // planea.translate( 100, 30, 30)
                // var pos = icrs_to_threejs( [ -100, 50, 50])
                // neb_plane.rotation.z = rotation * DEG2RAD
                

                // var pos = icrs_to_threejs( [x, y, z])
                // neb_plane.position.x = 0
                // neb_plane.position.y = 0
                // neb_plane.position.z = -10
                

                var pos = icrs_to_threejs( [x, y, z])
                neb_plane.position.x = pos[0]
                neb_plane.position.y = pos[1]
                neb_plane.position.z = pos[2]

                // neb_plane.rotation = rotation
                neb_plane.lookAt( new THREE.Vector3( 0, 0, 0))
                // neb_plane.rotation.z = (  Math.PI / 4)
                // neb_plane.position.x = 100
                // neb_plane.position.y = 0
                // neb_plane.position.z = 0

                // neb_plane.lookAt(150, 100, 50); 
                var axis = new THREE.Vector3(0, 0, 1);
                neb_plane.rotateOnAxis(axis, -rotation * DEG2RAD);

                // neb_plane.lookAt( new THREE.Vector3( 0, 0, 0))
                // neb_plane.rotateY(  Math.PI / 4)
                // neb_plane.rotateZ(  Math.PI / 4)

                // var axis = new THREE.Vector3( pos[0], pos[1], pos[2] );
                // var deg = 43;
                // var angle = deg * (Math.PI / 180);
                // neb_geometry.applyAxisAngle( axis, angle ); 

                // geometry.lookAt( new THREE.Vector3( -100, -30, -30))
                scene.add( neb_plane );
                }

        }
        // add_labels_to_scene( scene, nebula_targets)
        tour_targets = nebula_targets.concat( tour_targets)
    }

    if (method == 0) {
        // The old 

        // let map = new THREE.TextureLoader().load("nebulae/i2qvMyMDQfwWCzBFn8wPF6.jpg");
        let map = new THREE.TextureLoader().load("nebulae/i2qvMyMDQfwWCzBFn8wPF6.jpg");
        let bmap = new THREE.TextureLoader().load("nebulae/i2qvMyMDQfwWCzBFn8wPF6.jpg");
        let dmap = new THREE.TextureLoader().load("nebulae/out.jpg");
        // let amap = new THREE.TextureLoader().load("nebulae/alpha.jpg");
        let amap = new THREE.TextureLoader().load("nebulae/alpha.jpg");
        let amaterial = new THREE.MeshPhongMaterial({
            // color: 0xffff00, 
            side: THREE.DoubleSide,
            bumpMap: bmap,
            bumpScale: 1.3,
            displacementMap: dmap,
            displacementBias: 2,
            displacementScale: -15,
            transparent: true,
            alphaMap: amap,
            depthTest: false,
            // alphaTest: 0.05,
            reflectivity: 0,
            opacity: 0.2,
            map: map
        });
        let bmaterial = new THREE.MeshPhongMaterial({
            // color: 0xffff00, 
            side: THREE.DoubleSide,
            bumpMap: bmap,
            bumpScale: 1.3,
            displacementMap: dmap,
            displacementBias: -2,
            displacementScale: 15,
            transparent: true,
            alphaMap: amap,
            depthTest: false,
            // alphaTest: 0.05,
            reflectivity: 0,
            map: map
        });

        const geometry = new THREE.PlaneGeometry( 100, 100, 200, 200 );
        // const geometry = new THREE.PlaneGeometry( 100, 100, 1000, 1000 );
        const material = new THREE.MeshBasicMaterial({
            color: 0xffff00, 
            side: THREE.DoubleSide
        } );



        // geometry.translate( 100, 30, 30)
        const planea = new THREE.Mesh( geometry, amaterial );
        // planea.translate( 100, 30, 30)
        planea.position.x = 100
        planea.position.y = 50
        planea.position.z = 50
        planea.lookAt( new THREE.Vector3( 0, 0, 0))
        // geometry.lookAt( new THREE.Vector3( -100, -30, -30))
        scene.add( planea );

        const planeb = new THREE.Mesh( geometry, bmaterial );
        planeb.position.x = 100
        planeb.position.y = 50
        planeb.position.z = 50
        planeb.lookAt( new THREE.Vector3( 0, 0, 0))
        scene.add( planeb );

        // Here we'll try using mesh with displacement maps.
        // let map = new THREE.TextureLoader().load("nebulae/out.png");
        // let map = new THREE.TextureLoader().load("nebulae/i2qvMyMDQfwWCzBFn8wPF6.jpg");
        // let ageometry = new THREE.PlaneGeometry( 400, 450, 50, 50);
        // // let ageometry = new THREE.PlaneGeometry( 4000, 4500, 500, 500);
        // // geometry.position.x = 0
        // // geometry.position.y = 0
        // // geometry.position.z = 0
        // let brickWall = new THREE.Mesh(ageometry,amaterial);
        // scene.add(brickWall);
        // var points = new THREE.Points( ageometry, amaterial );
        // scene.add( points );

    }


    if (method == 1) {

        // This method generates sprites for each image coordinate, and adds depth based on the brightness of the RGB components. It works but needs lots of tweaking still
        var canvas = document.createElement("canvas");

        var pic = new Image(); 
        pic.src = 'nebulae/out.png'; 
        pic.onload = function() {

            canvas.width = pic.width;
            canvas.height = pic.height;
            var ctx = canvas.getContext("2d");

            ctx.drawImage(pic, 0, 0);

            var c = canvas.getContext('2d');
            var p = c.getImageData(107, 107, 1, 1).data;
            var hex = "RGB = " + p[0]+", "+p[1]+", "+p[2];
            console.log( 'colors: ', p, hex)

            var p = c.getImageData( 80, 80, 1, 1).data;
            var hex = "RGB = " + p[0]+", "+p[1]+", "+p[2];
            console.log( 'colors: ', p, hex)

            // Transform image to cubes
            var pixel
            var c;
            var x, y, z;
            var actually_added = 0;
            var stars_geometry = new THREE.BufferGeometry();
            
            // var amount = cube_data.length
            // const positions = new Float32Array( );
            // const colors = new Float32Array( );
            // const sizes = new Float32Array( );
            const positions = [];
            const colors = [];
            const sizes = [];

            for (var y = 1; y < pic.height; y++) {
                for (var z = 1; z < pic.width; z++) {
                    pixel = c.getImageData( z, y, 1, 1).data;
                    /*
                    Yeah cubes without shader language optimization is not the way forward
                    i.e. displaying a few hundred cubes slows it all down to a crawl.
                    It's not impossible, see here:
                    https://codepen.io/zadvorsky/pen/mwqQaJ
                    But will require much more study.
                    */
                    /*
                    var cube = new THREE.Mesh(
                    new THREE.BoxGeometry( 1, 1, 1),
                    new THREE.MeshBasicMaterial({
                        // color: Math.random() * 0x0000FF, // + 0x000080,
                        color: 0x0000FF,
                        // color: 0x8888AA,
                        transparent: true,
                        // opacity: Math.random() * 0.1,
                        opacity: 0.1,
                    })
                    );
                    
                    cube.position.x = 50
                    cube.position.y = 50 + pic.height - y
                    cube.position.z = 100 + z
                    // cube.material.opacity = 0.3
                    // cube.material.color = Math.random() * 0x000080 + 0x606080,
                    // cube.material.color = new THREE.Color()
                    cube.material.opacity = 0.3; // * (x+y+z)/30
                    // var hex = "RGB = " + p[0]+", "+p[1]+", "+p[2];
                    pixel = c.getImageData( z, y, 1, 1).data;
                    cube.material.color.setRGB( pixel[0] / 256, pixel[1] / 256, pixel[2] / 256) // + 0x000080,
                    // cube.scale.x= cube.scale.y = cube.scale.z = Math.random();
                    // console.log('cube: ', cube)
                    scene.add(cube);
                    */
                    x = 50
                    positions.push(x)
                    positions.push(pic.height - y)
                    positions.push(z)
                    colors.push( pixel[0] / 256)
                    colors.push( pixel[1] / 256)
                    colors.push( pixel[2] / 256)
                    sizes.push( 15)


                    // Add depth cubes/pixels
                    // var depth = parseInt( 0.25 * pic.width * (pixel[0] + pixel[1] + pixel[2]) / (256 * 3))
                    
                    // Depth based on pixel value
                    // var depth = parseInt( 0.5 * pic.width * (pixel[0] + pixel[1] + pixel[2]) / (256 * 3))

                    // Depth based on it being a spheroid
                    var depth = 0.5 * parseInt(
                        Math.sqrt(
                            Math.cos( 
                            Math.PI * Math.abs( 0.5*pic.height - y) / pic.height
                        )**2
                        *
                        Math.sin( 
                            Math.PI * Math.abs( 0.5*pic.width - x) / pic.width
                        )**2
                        )
                        * pic.width
                    )

                    console.log( 'depth', depth)


                    var dimm_factor = 1;
                    var depth_x = 0;
                    for (var x = -depth; x < depth; x++) {
                        /*
                        var cube = new THREE.Mesh(
                        new THREE.BoxGeometry( 1, 1, 1),
                        new THREE.MeshBasicMaterial({
                            // color: Math.random() * 0x0000FF, // + 0x000080,
                            color: 0x0000FF,
                            // color: 0x8888AA,
                            transparent: true,
                            // opacity: Math.random() * 0.1,
                            opacity: 0.1,
                        })
                        );
                        cube.position.x = 50 + x
                        cube.position.y = 50 + pic.height - y
                        cube.position.z = 100 + z
                        */
                        depth_x = 50 + x
                        dimm_factor = (1 - Math.abs( x / depth)) ** 3
                        if (dimm_factor < 0.1) continue;
                        /*
                        // cube.material.opacity = 0.3 * dimm_factor
                        // pixel = c.getImageData( z, y, 1, 1).data;
                        // var hex = "RGB = " + p[0]+", "+p[1]+", "+p[2];
                        cube.material.color.setRGB( pixel[0] / 256, pixel[1] / 256, pixel[2] / 256) // + 0x000080,
                        // cube.scale.x= cube.scale.y = cube.scale.z = Math.random();
                        // console.log('cube: ', cube)
                        scene.add(cube);
                        */
                        positions.push(depth_x)
                        positions.push(pic.height - y)
                        positions.push(z)
                        colors.push( pixel[0] / 256)
                        colors.push( pixel[1] / 256)
                        colors.push( pixel[2] / 256)
                        // colors.push( dimm_factor * pixel[0] / 256)
                        // colors.push( dimm_factor * pixel[1] / 256)
                        // colors.push( dimm_factor * pixel[2] / 256)
                        sizes.push( dimm_factor * 5)

                    }
                    

                
                }
            }

            // Arrays have now been populated with x,y,z and color info
            console.log( positions, colors)
            stars_geometry.setAttribute( 'size', new THREE.BufferAttribute( new Float32Array(sizes), 1 ) );
            stars_geometry.setAttribute( 'position', new THREE.BufferAttribute( new Float32Array( positions), 3 ) );
            stars_geometry.setAttribute( 'customColor', new THREE.BufferAttribute( new Float32Array(colors), 3 ) );

            const point_material = new THREE.ShaderMaterial( {
                uniforms: {
                    color: { value: new THREE.Color( 0xffffff ) },
                    // pointTexture: { value: new THREE.TextureLoader().load( 'three.js/textures/sprites/spark1.png' ) }
                    // https://www.cleanpng.com/png-sparkling-star-download-light-302543/download-png.html
                    pointTexture: { value: new THREE.TextureLoader().load( 'images/cloud1.png' ) }

                },
                vertexShader: document.getElementById( 'vertexshader' ).textContent,
                fragmentShader: document.getElementById( 'fragmentshader' ).textContent,

                // blending: THREE.AdditiveBlending, <- Makes nebula way too bright
                // blending: THREE.Normal, // <- is OK
                // blending: THREE.Multiply, <- Maybe not so good as causes dimming from some angles
                depthTest: false,
                transparent: true,
                vertexColors : true
                // flatShading: true

            } );
            var points = new THREE.Points( stars_geometry, point_material );
            scene.add( points );

    }
    






}
    // document.getElementById("output").innerHTML = hex; 




    // let img = new (window as any).Image();
    // img.crossOrigin = `Anonymous`;

    // img.src = "nebulae/out.png";
    // img.onload = function () {
    //     canvas = document.getElementById("myCanvas") as HTMLCanvasElement;
    //     canvas.width = img.width;
    //     canvas.height = img.height;
    //     let ctx: CanvasRenderingContext2D = canvas.getContext(
    //         "2d"
    //     ) as CanvasRenderingContext2D;
    //     ctx.drawImage(img, 0, 0);

    //     const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    //     data = imgData.data;
    //     canvas.addEventListener("mousemove", (ev) => {
    //         //as the mouse moves around the image
    //         let cols = canvas.width;
    //         let { offsetX, offsetY } = ev;
    //         //call the method to get the r,g,b,a values for current pixel
    //         let c = extractPixelColor(cols, offsetY, offsetX);
    //         //build a colour string for 
    //         let colour = `rgb(${c.red}, ${c.green}, ${c.blue})`} ;
    //         let hexCode = `#${[c.red, c.green, c.blue]
    //             .map((x) => x.toString(16).padStart(2, "0"))
    //             .join("")}`;
            
    //     });
    // };


}


function add_cubes_to_scene( scene, cube_data) {
    console.log('Entering cubes ....')
    /*
    theta: props.theta || 0.1,
      radius: props.radius || 600,
      opacity: props.opacity || 0.2,
      count: props.count || 150,
      palette: props.palette || null,
    //   */  
    //   const { palette, opacity } = this;
    // if (Array.isArray(palette)) {
    //   const cubeColor = palette[Math.floor(
    //     Math.random() * palette.length
    //   )];
    // }

    // const cube = new THREE.Mesh(
    //   new THREE.BoxGeometry( 50, 50, 50),
    //   new THREE.MeshBasicMaterial({
    //     // color: Math.random() * 0x000080 + 0x808080,
    //     color: 0x8888AA,
    //     transparent: true,
    //     opacity: 0.2,
    //   })
    // );


    // console.log( cube_data)
    var c;
    var x, y, z;
    var actually_added = 0;
    for (var cube_idx = 0; cube_idx < cube_data.length; cube_idx++) {
        // var cube = new THREE.Mesh(
        //     // new THREE.BoxGeometry( 49, 49, 49),
        //     new THREE.BoxGeometry( 1* data_set_xyz_multiplier, 1* data_set_xyz_multiplier, 1* data_set_xyz_multiplier),
        //     new THREE.MeshBasicMaterial({
        //     // color: Math.random() * 0x0000FF, // + 0x000080,
        //     color: 0x8888AA,
        //     // transparent: true,
        //     // opacity: Math.random() * 0.1,
        //     wireframe: true,
        //     // opacity: 0.1,
        // })
        // );
        // // Values were rounded, so move down each axis by half
        // x = (cube_data[ cube_idx][0] - 0.5) * data_set_xyz_multiplier
        // y = (cube_data[ cube_idx][1] - 0.5) * data_set_xyz_multiplier
        // z = (cube_data[ cube_idx][2] - 0.5) * data_set_xyz_multiplier
        // c = cube_data[ cube_idx][3]
        // if (c < 0.05) continue;
        // actually_added++;
        // cube.position.x = x
        // cube.position.y = y
        // cube.position.z = z
        // cube.material.color.setRGB( c, c, c)
        // scene.add(cube);

        // var dotGeometry = new THREE.BufferGeometry();
        // dotGeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( 
        //     [ x, y, z], 3 
        // ) );
        // var dotMaterial = new THREE.PointsMaterial( { size: 0.3  * data_set_xyz_multiplier, color: 0x00ff00 } );
        // dotMaterial.color.setRGB( c, c, c)
        // var dot = new THREE.Points( dotGeometry, dotMaterial );
        // scene.add( dot );

        // cube.material.opacity = 0.3
        // cube.material.color = Math.random() * 0x000080 + 0x606080,
        // cube.material.color = new THREE.Color()
        // cube.material.opacity = 0.3 * (x+y+z)/30
        //, // + 0x000080,

    }

    var stars_geometry = new THREE.BufferGeometry();
    var amount = cube_data.length
    const positions = new Float32Array( amount * 3 );
    const colors = new Float32Array( amount * 3 );
    const sizes = new Float32Array( amount);    
    
    // const color = new THREE.Color( 0xff00ff );
    for (var i = 0; i < amount; i++) {
        x = (cube_data[ i][0] - 0.5) * data_set_xyz_multiplier
        y = (cube_data[ i][1] - 0.5) * data_set_xyz_multiplier
        z = (cube_data[ i][2] - 0.5) * data_set_xyz_multiplier
        c = cube_data[  i][3]
        positions[i*3+0] = x
        positions[i*3+1] = y
        positions[i*3+2] = z
        colors[i*3+0] = c
        colors[i*3+1] = c
        colors[i*3+2] = c
        
        // positions[i*3+1] = bucket['positions'][i][1];
        // positions[i*3+2] = bucket['positions'][i][2];
        // console.log( 'ALERT 5', amount, bucket['positions'][i], positions[i*3], bucket['positions'][i][0])
        // color.toArray( colors, i * 3 );
        // colors.push( c * 256, c * 256, c * 256)
        sizes[i] = (c**2) * data_set_xyz_multiplier * 20
    }    
    
    // for (var i = 0; i < cube_data.length; cube_idx++) sizes[i] = cube_data[ i][3] * data_set_xyz_multiplier / 2

    // for (var i = 0; i < amount; i++) sizes[i] = size;
    stars_geometry.setAttribute( 'size', new THREE.BufferAttribute( sizes, 1 ) );
    stars_geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
    stars_geometry.setAttribute( 'customColor', new THREE.BufferAttribute( colors, 3 ) );

    const point_material = new THREE.ShaderMaterial( {
        uniforms: {
            color: { value: new THREE.Color( 0xffffff ) },
            // pointTexture: { value: new THREE.TextureLoader().load( 'three.js/textures/sprites/spark1.png' ) }
            // https://www.cleanpng.com/png-sparkling-star-download-light-302543/download-png.html
            pointTexture: { value: new THREE.TextureLoader().load( 'images/star-glare6.png' ) }

        },
        vertexShader: document.getElementById( 'vertexshader' ).textContent,
        fragmentShader: document.getElementById( 'fragmentshader' ).textContent,

        blending: THREE.AdditiveBlending,
        // blending: THREE.Normal,
        // blending: THREE.MultiplyBlending,
        depthTest: false,
        transparent: true,
        vertexColors : true
        // flatShading: true

    } );

    var points = new THREE.Points( stars_geometry, point_material );
    scene.add( points );
    
    // return amount;
    // return actually_added;
    // for (var y = 1; y < 10; y++) {
    //     for (var x = 1; x < 10; x++) {
    //         for (var z = 1; z < 10; z++) {
    //             var cube = new THREE.Mesh(
    //                 // new THREE.BoxGeometry( 49, 49, 49),
    //                 new THREE.BoxGeometry( 50, 50, 50),
    //                 new THREE.MeshBasicMaterial({
    //                 color: Math.random() * 0x0000FF, // + 0x000080,
    //                 // color: 0x8888AA,
    //                 // transparent: true,
    //                 // opacity: Math.random() * 0.1,
    //                 wireframe: true,
    //                 // opacity: 0.1,
    //             })
    //             );
    //             cube.position.x = x * 50 + 100
    //             cube.position.y = y * 50
    //             cube.position.z = z * 50
    //             // cube.material.opacity = 0.3
    //             // cube.material.color = Math.random() * 0x000080 + 0x606080,
    //             // cube.material.color = new THREE.Color()
    //             // cube.material.opacity = 0.3 * (x+y+z)/30
    //             cube.material.color.setRGB( ((30 - (x+y+z))/30)**4, ((10-z)/10)**4, ((x+y+z)/30)**4), // + 0x000080,
    //             // cube.scale.x= cube.scale.y = cube.scale.z = Math.random();
    //             // console.log('cube: ', cube)
    //             scene.add(cube);
    //         }
        
    //     }
    // }
}

function add_labels_to_scene( scene, labels, size = 1) {
    
    var line_points = [];
    var i = 0;
    var new_line = []
    // var poi_dist = 0.2;
    // var text_size = 0.2;
    var poi_dist = 4 * size;
    var text_size = 1 * size;

    var l;


    // const message = '   Three.js\nSimple text.';
    const message = 'TEST';

    // const loader = new FontLoader();
    // loader.load( 'three.js/jsm/fonts/helvetiker_regular.typeface.json', function ( font ) {

    // const color = 0x006699;
    const color = 0x60FF60;

    const matDark = new THREE.LineBasicMaterial( {
        color: color,
        side: THREE.DoubleSide
    } );

    const matLite = new THREE.MeshBasicMaterial( {
        color: color,
        transparent: true,
        opacity: 0.4,
        side: THREE.DoubleSide
    } );
    // })


    var tjs_c = [];

    for( i = 0; i < labels.length; i += 1) {
        l = labels[i]
        new_line = []
        tjs_c = icrs_to_threejs( [l[0] , l[1] , l[2] ])
	    new_line.push( new THREE.Vector3( tjs_c[0] + poi_dist, tjs_c[1] + poi_dist, tjs_c[2] + poi_dist) );
	    new_line.push( new THREE.Vector3( tjs_c[0] + poi_dist * 2, tjs_c[1]+ poi_dist * 2, tjs_c[2] + poi_dist * 2) );
	    new_line.push( new THREE.Vector3( tjs_c[0] + poi_dist * 3, tjs_c[1] + poi_dist * 2, tjs_c[2] + poi_dist * 3) );
        // line_points.push( new_line)

        const line_geometry = new THREE.BufferGeometry().setFromPoints( new_line );
        const material = new THREE.LineBasicMaterial( { color: 0x60FF60 } );
        /* const line = new THREE.Line( geometry, material ); */
        const three_line = new THREE.Line( line_geometry, material );
        scene.add( three_line)

        // const shapes = font.generateShapes( message, 100 );
        const shapes = label_font.generateShapes( l[3], text_size );
        // console.log( l[3])

        const geometry = new THREE.ShapeGeometry( shapes );

        geometry.computeBoundingBox();

        const xMid = - 0.5 * ( geometry.boundingBox.max.x - geometry.boundingBox.min.x );

        // geometry.translate( xMid +l[0] + poi_dist * 3, l[1] + poi_dist * 3, l[2] + poi_dist * 3);
        geometry.translate( xMid, 0, 0);
    

        // make shape ( N.B. edge view not visible )

        const text = new THREE.Mesh( geometry, matDark );
        label_meshes.push( text)
        // text.position.z = - 150;

        text.position.x = tjs_c[0] + poi_dist * 3
        text.position.y = tjs_c[1] + poi_dist * 2 + 0.2;
        text.position.z = tjs_c[2] + poi_dist * 3;
        scene.add( text );


    };
    labels_loaded = true;    

}

function fix_labels_orientation( ) {
    // console.log('fix_labels() ...')
    if (labels_loaded) {
        // rotate them towards the camera
        for (var i = 0; i < label_meshes.length; i++) {
            // console.log( 'fix label: ', i)
            // label_meshes[i].lookAt( camera.position );
            label_meshes[i].quaternion.copy(camera.quaternion);;
        }
    }

}

function add_stars_to_scene( scene, star_coords) {
    // console.log('Entering stars ....')

    const positions = [];
    // const size_buckets = {};
    const colors = [];
    const sizes = [];
    
    // var colors = [];
    var color_array = [];
    var veff_color = 0;
    var Wavelength = 0;
    var Red = 0;
    var Green = 0;
    var Blue = 0;
    var Teff = 0;
    const color = new THREE.Color();

    // console.log( star_coords.length);
    // // console.log( star_colors.length);
    // console.log( star_coords[star_coords.length-1]);

    var apparent_magnitude = 10;
    var dimming_factor = 1;
    var temperature = 0;
    var red, green, blue;
    var distance;
    var abs_magnitude;
    var x, y, z;
    var temperature_fudge_factor = 1.4;
    var hsl = {};
    var star_size;
    var tjs_xyz = [];

    for ( var i = 0; i < star_coords.length; i += 1) {

        x = star_coords[i][0];
        y = star_coords[i][1];
        z = star_coords[i][2];
        veff_color = star_coords[i][3];
        abs_magnitude = star_coords[i][4];

        // if (
        //        (x > -1) && (x < 1)
        //     && (y > -1) && (y < 1)
        //     && (z > -1) && (z < 1)
        //     ) console.log('xyz: ', x, y, z);

        // TODO: Add filtering based on GUI options selected
        // distance = Math.sqrt( x**2 + y**2 + z**2)
        
        // if (distance > 2500) continue;
        // if ( stars_filter == 'da_hood')
        //     if ((distance > 3000) || (abs_magnitude > 5)) continue;

        // if ( stars_filter == 'galactic')
        //     if ((distance > 70000) || (abs_magnitude > -3)) continue;
        // if ((distance < 3000) || (distance > 70000) || (abs_magnitude > -5)) continue;
        // if (distance < 100) continue;
        // if (total_stars_in_scene > 1000) continue;

        /*
        Quick absolute magnitude bucket check from a single source file
        3 -9
        9 -8
        34 -7
        111 -6
        459 -5
        1516 -4
        4407 -3
        9748 -2
        17694 -1
        30381 -0
        40426 0
        43501 1
        40873 2
        36897 3
        31345 4
        24082 5
        14950 6
        7328 7
        2546 8
        589 9
        72 10
        5 11
        */

        /*
        // Aim to make the stars between 0.2 and 3 in size to ensure reasonable
        // spread over the absolute magitude bucket sized above
        var star_size = parseInt( 20 - (parseInt(abs_magnitude) + 10)) / 5
        if (star_size > 3) star_size = 3;
        if (star_size < 0.2) star_size = 0.2;
        */
        // With the shader material it's better to make it size 0 - 10?
        // spread over the absolute magitude bucket sized above
        // var star_size = (10 - parseInt(abs_magnitude)) / 2
        // Or maybe a more exponential size is better given magnitude's exponential scale?
        star_size = (10 - parseInt(abs_magnitude)) / 2
        // star_size = star_size ** 2 / 10
        star_size = star_size ** 3 / 100

        if (star_size > 10) star_size = 10;
        if (star_size < 1) star_size = 1;

        sizes.push( star_size)

        // initialize bucket if needed:
        // if ( ! (star_size in size_buckets)) {
        //     // console.log( 'Need to create bucket: ' + star_size)
        //     size_buckets[ star_size] = {
        //         positions: [],
        //         colors: []
        //     }
        // }
        
        // size_buckets[ star_size]['positions'].push( x, y, z);
        tjs_xyz = icrs_to_threejs( [x, y, z])
        positions.push( tjs_xyz[0], tjs_xyz[1], tjs_xyz[2]);
        if (distance > star_max_dist) star_max_dist = distance;


        // Dim the brightness of the RGB values further according to magnitude
        dimming_factor = ((900 - ((abs_magnitude+8)**2)) / 900)
        
        if (dimming_factor > 1) dimming_factor = 1;
        if (dimming_factor < 0.1) dimming_factor = 0.1;

        if (veff_color == 0) { color.setRGB( 1, 1, 1) }
        else {
            // Î½eff, in Î¼mâˆ’1
            // veff -> rgb: https://stackoverflow.com/questions/1472514/convert-light-frequency-to-rgb
            // Teff -> rgb: https://www.npmjs.com/package/color-temperature?activeTab=code

            // Wavelength = 1 / (veff_color * 10**-3)

            // For some reason 90% of stars come out red, so apply a fudge
            // factor. TODO: Find out how grown-ups calculate it properly
            Teff = 2.8977719 * veff_color * 1000 * temperature_fudge_factor

            // Calculate RGB values according to Teff 
            temperature = Teff / 100.0;

            // Red
            if (temperature <= 66.0) {
                red = 255;
            } else {
                red = temperature - 60.0;
                red = 329.698727446 * Math.pow(red, -0.1332047592);
                if (red < 0) red = 0;
                if (red > 255) red = 255;
            }

            /* Calculate green */
            if (temperature <= 66.0) {
                green = temperature;
                green = 99.4708025861 * Math.log(green) - 161.1195681661;
                if (green < 0) green = 0;
                if (green > 255) green = 255;
            } else {
                green = temperature - 60.0;
                green = 288.1221695283 * Math.pow(green, -0.0755148492);
                if (green < 0) green = 0;
                if (green > 255) green = 255;
            }

            /* Calculate blue */
            if (temperature >= 66.0) {
                blue = 255;
            } else {
                if (temperature <= 19.0) {
                    blue = 0;
                } else {
                    blue = temperature - 10;
                    blue = 138.5177312231 * Math.log(blue) - 305.0447927307;
                    if (blue < 0) blue = 0;
                    if (blue > 255) blue = 255;
                }
            }

            // console.log( Wavelength)
            // if (i % 100000 == 0) { 
            // 	console.log( apparent_magnitude, dimming_factor, Teff, red, green, blue) 
            // 	console.log( red*dimming_factor/255, green*dimming_factor/255, blue*dimming_factor/255);
            // }
            color.setRGB( red*dimming_factor/255, green*dimming_factor/255, blue*dimming_factor/255);
            color.getHSL( hsl)
            // color.setHSL( hsl.h, (hsl.s + 1) / 2, (hsl.l + 0.5) / 2)
            // color.setHSL( hsl.h, (hsl.s + 1.0) / 2.0, hsl.l)
            color.setHSL( hsl.h, hsl.s + 0.05, hsl.l - 0.1)

            // target â€” the result will be copied into this Object. Adds h, s and l keys to the object (if not already present).

            // Convert this Color's r, g and b values to HSL format and returns an object of the form:
            // { h: 0, s: 0, l: 0 }

            // Move lightness closer to halfway (pure color) and saturation closed to 1 (brighter colour)
            
        }
        colors.push( color.r, color.g, color.b );
    };

    // add all computed buckets to the scene
    var stars_geometry;
    var total_added = 0;
    // console.log( 'size bucket keys: ', Object.keys(size_buckets))
    // for (const [size, bucket] of Object.entries(size_buckets)) {
        // console.log(size, bucket);
    
        stars_geometry = new THREE.BufferGeometry();
        // stars_geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( bucket['positions'], 3 ) );
        // stars_geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( bucket['colors'], 3 ) );
        // var amount = bucket['positions'].length
        // const positions = new Float32Array( amount * 3 );
        // const colors = new Float32Array( amount * 3 );
        // const color = new THREE.Color( 0xff00ff );
        // for (var i = 0; i < amount; i++) {
        //     positions[i] = bucket['positions'][i];
            // positions[i*3+1] = bucket['positions'][i][1];
            // positions[i*3+2] = bucket['positions'][i][2];
            // console.log( 'ALERT 5', amount, bucket['positions'][i], positions[i*3], bucket['positions'][i][0])
            // color.toArray( colors, i * 3 );
        //     colors[i] = bucket['colors'][i]
        // }
        
        stars_geometry.setAttribute( 'position', new THREE.BufferAttribute( new Float32Array( positions), 3 ) );
        stars_geometry.setAttribute( 'customColor', new THREE.BufferAttribute( new Float32Array(colors), 3 ) );
        // var sizes = Array( bucket['positions'].length).fill( size)
        // const sizes = new Float32Array( amount);
        // for (var i = 0; i < amount; i++) sizes[i] = size * 3;
        // for (var i = 0; i < amount; i++) sizes[i] = size;
        stars_geometry.setAttribute( 'size', new THREE.BufferAttribute( new Float32Array(sizes), 1 ) );

        const point_material = new THREE.ShaderMaterial( {
            uniforms: {
                color: { value: new THREE.Color( 0xffffff ) },
                // pointTexture: { value: new THREE.TextureLoader().load( 'three.js/textures/sprites/spark1.png' ) }
                // https://www.cleanpng.com/png-sparkling-star-download-light-302543/download-png.html
                pointTexture: { value: new THREE.TextureLoader().load( 'images/star-glare6.png' ) }
                // pointTexture: { value: new THREE.TextureLoader().load( 'images/star-glare7.png' ) }

            },
            vertexShader: document.getElementById( 'vertexshader' ).textContent,
            fragmentShader: document.getElementById( 'fragmentshader' ).textContent,

            blending: THREE.AdditiveBlending,
            // blending: THREE.NormalBlending,
            depthTest: false,
            transparent: false,
            vertexColors : true
            // flatShading: true

        } );

        /*
        Since custom properties apparently don't stick, we instead 
        appropiate .name for the original size, as we need to 
        increase/descrease size on the fly when toggling 
        the .sizeAttenuation property.
        */
        // const point_material = new THREE.PointsMaterial( { 
        //     size: size * global_sizeAttenuation_multiplier, 
        //     name: size,
        //     sizeAttenuation: global_sizeAttenuation, map: sprite, 
        //     alphaTest: 0.5, transparent: false, vertexColors: true 
        // } );

        var points = new THREE.Points( stars_geometry, point_material );
        scene.add( points );

        // console.log( bucket)
        // for (var l = 0; l < bucket['positions'].length; l++) {
        //     const light = new THREE.PointLight( bucket['colors'][l], size * 3, size * 100);
		// 			// light.color.setHSL( h, s, l );
		// 			light.position.set( 
        //                 bucket['positions'][l][0],
        //                 bucket['positions'][l][1],
        //                 bucket['positions'][l][2]
        //             );
		// 			scene.add( light );
        // }

        // total_added += bucket['positions'].length / 3;
        total_added += positions.length / 3;
        // console.log('DEBUG1 Added size/# new stars: ', size, bucket['positions'].length)
    // }
    // console.log('DEBUG1', star_max_dist)
    // console.log('Added # new stars to scene: ', total_added);

    // const axesHelper = new THREE.AxesHelper( star_max_dist );
    // scene.add( axesHelper );
    return total_added;
}

// Based on SO answers pointing to most recent JS standards and usage. What do I know.
function loadScript (scene, sky_element, async = false, type = "text/javascript") {
	// var filename = './data/' + sky_element + '.js';
    // New data set format:
    // url: data/set-star_density/8.js

	// for local files
    // var filename = './data/set-' + data_set + '/' + sky_element + '.js';
	// For split repositories and use on Github Pages:
    var filename = '../gaia-web-data/set-' + data_set + '/' + sky_element + '.js';
	var FILE_URL = filename;

	if (loading_lock) {
		// Try again next time
		// return 0
	}
	loading_lock = true;

    return new Promise((resolve, reject) => {
        try {
            const scriptEle = document.createElement("script");
            scriptEle.type = type;
            scriptEle.async = async;
            scriptEle.src = FILE_URL;

            scriptEle.addEventListener("load", (ev) => {
                resolve({ status: true });
                // Add the data to all_stars[] where it will be checked and read from later
				// all_stars[sky_element] = stars;
				all_stars[sky_element] = data;
				loading_lock = false;

                var num_loaded = Object.keys( all_stars).length;
                var total = available_elements.length
				console.log("Parsed file " + num_loaded + ' of ' + total
                    + ' (' + sky_element + '): #'
                    + all_stars[sky_element].length + " " + data_set_type + "' data loaded.");
                


				// add_stars_to_scene( scene, stars)
				// console.log('DEBUG3', star_max_dist)
				// console.log('DEBUG32', Object.keys(all_stars))
				// console.log('DEBUG33 loading lock', loading_lock)
				load_next_sky_element()
            });

            scriptEle.addEventListener("error", (ev) => {
                reject({
                    status: false,
                    message: `Failed to load the script ` + FILE_URL
                });
				loading_lock = false;
            });

            document.body.appendChild(scriptEle);
        } catch (error) {
            reject(error);
			loading_lock = false;
        }
    });
};


function init() {

    const aspect = window.innerWidth / window.innerHeight;

    scene = new THREE.Scene();

    // Andromeda is 2.5 * 10**6 away
    var far_away = 10**7
    perspectiveCamera = new THREE.PerspectiveCamera( 60, aspect, 1, far_away );
    
    // Position next to Hyades, looking towards Sol & Galaxy center
    var p = earth_hyades_milkyway_bg
    perspectiveCamera.position.set( p[0], p[1], p[2] )
    perspectiveCamera.lookAt( 0, -50, 0 );

    orthographicCamera = new THREE.OrthographicCamera( frustumSize * aspect / - 2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, 1, star_max_dist );
    // orthographicCamera.position.x =
    // orthographicCamera.position.y =
    // orthographicCamera.position.z = 10000;

    // world

    // scene.background = new THREE.Color( 0xcccccc );
    // scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );

    // const geometry = new THREE.CylinderGeometry( 0, 10, 30, 4, 1 );
    // const material = new THREE.MeshPhongMaterial( { color: 0xffffff, flatShading: true } );

    // for ( let i = 0; i < 500; i ++ ) {

    // 	const mesh = new THREE.Mesh( geometry, material );
    // 	mesh.position.x = ( Math.random() - 0.5 ) * 1000;
    // 	mesh.position.y = ( Math.random() - 0.5 ) * 1000;
    // 	mesh.position.z = ( Math.random() - 0.5 ) * 1000;
    // 	mesh.updateMatrix();
    // 	mesh.matrixAutoUpdate = false;
    // 	scene.add( mesh );

    // }

    // // lights

    // const dirLight1 = new THREE.DirectionalLight( 0xffffff );
    // dirLight1.position.set( 1, 1, 1 );
    // scene.add( dirLight1 );

    // const dirLight2 = new THREE.DirectionalLight( 0x002288 );
    // dirLight2.position.set( - 1, - 1, - 1 );
    // scene.add( dirLight2 );

    // const ambientLight = new THREE.AmbientLight( 0x222222 );
    // scene.add( ambientLight );

    // renderer

    renderer = new THREE.WebGLRenderer( { antialias: true } );
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );

    stats = new Stats();
    document.body.appendChild( stats.dom );


    // load_file('7gaiasources');
    // loadJS( scene, '7gaiasources', false);
    // loadJS( scene, 'GaiaSource_005264-006601', false);
    // loadJS( scene, 'GaiaSource_003112-005263', false);


    // console.log('DEBUG2', star_max_dist)
    // console.log('DEBUG2', Object.keys(all_stars))

    if (we_want_axes) {
        scene.remove( axesHelper)
        axesHelper = new THREE.AxesHelper( star_max_dist );
        scene.add( axesHelper );
    }



    var rendered_sky_elements = []

    const interval1 = setInterval(function() {
        // method to be executed;
        // console.log( 'DEBUG4: ', Date())
        load_available_sky_elements()
    }, 2000);

    const interval2 = setInterval(function() {
        // method to be executed;
        // console.log( 'DEBUG5: ', Date())
        // console.log('DEBUG51 loading lock', loading_lock)

        if (! loading_lock && initial_scene_reloaded) load_next_sky_element();
    }, 2000);

    const interval3 = setInterval(function() {
        // method to be executed;

        var hash_value_here = 
            + camera_vector.x.toFixed(1) + ',' 
            + camera_vector.y.toFixed(1) + ',' 
            + camera_vector.z.toFixed(1) + '_'
            + camera.position.x.toFixed(1) + ','
            + camera.position.y.toFixed(1) + ',' 
            + camera.position.z.toFixed(1) 
        location.replace("#" + hash_value_here);

    }, 2000);

    const fl = new FontLoader().load( 'three.js/jsm/fonts/helvetiker_regular.typeface.json',
        function(font) {
            label_font = font;
        })
    // font = new FontLoader().parse( 'three.js/jsm/fonts/helvetiker_regular.typeface.json')

    const interval4 = setInterval(function() {
        // method to be executed;
        if (label_font !== undefined) {
            if (!labels_loaded) {
                add_labels_to_scene( scene, [
                    [ 0, 0, 0, 'Sol (you are here)']
                ].concat(tour_targets).concat(old_tour_targets)
                )
                // console.log( star_labels)
                add_labels_to_scene( scene, [
                    [ 0, 0, 0, 'The sun']
                ].concat( star_labels), 0.3
                )


            }
            fix_labels_orientation();
        }
        // console.log(label_font)
    }, 1000);



    var gui_drop_down = {}

    for (const [key, value] of Object.entries(gaia_web_datasets)) {
    // for (const name in gaia_web_datasets) {
        // console.log( `${key}: ${value}` );
        gui_drop_down[key] = key
    }
    console.log( gui_drop_down );

    const gui = new GUI( { title: 'Dataset' });
    
    gui.add( { x: data_set }, 'x', gui_drop_down ).name( 'Dataset' ).onChange( function ( value ) {
        if ( value != prev_data_set) {
            data_set = value
            reload_all_stars()
        }
        prev_data_set = data_set
    })
        // gui.add( { x: 2 }, 'x', { Label1: 0, Label2: 1, Label3: 2 } ).name( 'Dataset' );
    // make( { title: 'Options' }, gui => {

        // gui.add( { Options: 'a' }, 'Options', [ 'a', 'b', 'c' ] ).disable().enable();
	    // gui.add( { Options: 'a' }, 'Options', [ 'a', 'b', 'c' ] ).disable();
        // gui.add( { x: 0 }, 'x', [ 0, 1, 2 ] ).name( 'Array' );
        // gui.add( { x: {} }, 'x', [ 0, 1, 2 ] ).name( 'Invalid initial' );
        // gui.add( { x: {} }, 'x', { Label1: 0, Label2: 1, Label3: 2 } ).name( 'Invalid initial' );
        // gui.add( { func() { console.log( 'hi' ); } }, 'func' ).name( 'Function' ).disable().enable();
	    // gui.add( { func() { console.log( 'hi' ); } }, 'func' ).name( 'Function' ).disable();
        // const longString = 'Anoptionorvaluewithaproblematicallylongname';
        // gui.add( { x: longString }, 'x', [ longString, 1, 2 ] ).name( 'Long names' );
    // } );


    // for (var idx = 0; idx < gaia_web_datasets.length; idx++)
    //     console.log( gaia_web_datasets[idx])
    // for (var idx = 0; idx < gaia_web_datasets.length; idx++)
        // console.log( gaia_web_datasets[idx])


//     gui.add( params, '' ).name( 'Disable distance dimming (sizeAttentuation)' ).onChange( function ( value ) {

//         // controls.dispose();

//         // createControls( value ? orthographicCamera : perspectiveCamera );
//         // alert('hi')
//         // To set items still loading in right
//         global_sizeAttenuation = value ? false : true;
//         // console.log( "global attentuation", global_sizeAttenuation);

//         scene.traverse( function( node ) {
//             if ( node instanceof THREE.Points ) {
//                 // console.log( "toggling attentuation", node.material.sizeAttenuation)
//                 // insert your code here, for example:
//                 // console.log( node);
//                 node.material.sizeAttenuation = global_sizeAttenuation;
//                 node.material.needsUpdate = true;
//             }

//         } );
//         } );

//     // const cubeFolder = gui.addFolder('Cubes (averaged values)')
//     // cubeFolder.add(cube.rotation, 'x', 0, Math.PI * 2)
//     // cubeFolder.add(cube.rotation, 'y', 0, Math.PI * 2)
//     // cubeFolder.add(cube.rotation, 'z', 0, Math.PI * 2)
//     // cubeFolder.open()

//     // const cameraFolder = gui.addFolder('Camera')
//     // cameraFolder.add(camera.position, 'z', 0, 10)
//     // cameraFolder.open()




//     // TODO: build gui option for each params option

//     gui.add( params, 'option 1' ).name( 'Disable distance dimming (sizeAttentuation)' ).onChange( function ( value ) {

//         // controls.dispose();

//         // createControls( value ? orthographicCamera : perspectiveCamera );
//         // alert('hi')
//         // To set items still loading in right
//         global_sizeAttenuation = value ? false : true;
//         // console.log( "global attentuation", global_sizeAttenuation);

//         scene.traverse( function( node ) {
//             if ( node instanceof THREE.Points ) {
//                 // console.log( "toggling attentuation", node.material.sizeAttenuation)
//                 // insert your code here, for example:
//                 // console.log( node);
//                 node.material.sizeAttenuation = global_sizeAttenuation;
//                 node.material.needsUpdate = true;
//             }

//         } );
//     } );

// // function toggle_global_sizeAttenuation

//     gui.add( params, 'orthographicCamera' ).name( 'use orthographic' ).onChange( function ( value ) {

//         // controls.dispose();

//         // createControls( value ? orthographicCamera : perspectiveCamera );

//     } );

    //

    window.addEventListener( 'resize', onWindowResize );

    // createControls( perspectiveCamera );



    // camera = perspectiveCamera

    controls = new PointerLockControls( perspectiveCamera, document.body );
    // const blocker = document.getElementById( 'blocker' );
    // const instructions = document.getElementById( 'instructions' );

    const instructions = document.getElementById( 'instructions' );
    // const instructions = document.getElementById( 'body' );

    instructions.addEventListener( 'click', function () {
        controls.lock();
        tour_active = false;
    } );

    // controls.lock(); // lock the mouse to viewing angle

    controls.addEventListener( 'lock', function () {
        instructions.style.display = 'none';
        blocker.style.display = 'none';
    } );

    controls.addEventListener( 'unlock', function () {
        blocker.style.display = 'block';
        instructions.style.display = '';
        tour_active = false;
    } );				



    scene.add( controls.getObject() );

    document.onpointerup = function(event) {
        switch ( event.button ) {
            case 0: 
                // console.log("Left Button is UP."); 
                break;
            case 1: 
                // console.log("Middle Button is UP."); 
            //Beware this work not on mac with magic mouse!
                break;
            case 2: 
                // console.log("Right Button is UP.");
                zoom_camera( false);
                break;
        }
    }

    document.onpointerdown = function(event) {
        switch ( event.button ) {
            case 0: 
                // console.log("Left Button is down."); 
                break;
            case 1: 
                // console.log("Middle Button is down."); 
                //Beware this work not on mac with magic mouse!
                break;
            case 2: 
                // console.log("Right Button is down.");
                zoom_camera( true);
                break;
        }
    }


    const onKeyDown = function ( event ) {
        // console.log( event.button)
        switch ( event.code ) {
            case 'ArrowUp':
            case 'KeyW':
                moveForward = true;
                break;

            case 'ArrowLeft':
            case 'KeyA':
                moveLeft = true;
                break;

            case 'ArrowDown':
            case 'KeyS':
                moveBackward = true;
                break;

            case 'ArrowRight':
            case 'KeyD':
                moveRight = true;
                break;

            case 'KeyQ':
                moveDown = true;
                break;

            case 'KeyE':
                moveUp = true;
                break;


            case 'Space':
                warp_enabled = true
                break;

        }
    };

    const onKeyUp = function ( event ) {
        switch ( event.code ) {

            case 'ArrowUp':
            case 'KeyW':
                moveForward = false;
                break;

            case 'ArrowLeft':
            case 'KeyA':
                moveLeft = false;
                break;

            case 'ArrowDown':
            case 'KeyS':
                moveBackward = false;
                break;

            case 'ArrowRight':
            case 'KeyD':
                moveRight = false;
                break;

            case 'KeyQ':
                moveDown = false;
                break;

            case 'KeyE':
                moveUp = false;
                break;

            case 'KeyL':
                slow_down_cowboy = ! slow_down_cowboy
                break;

            case 'KeyG':
                camera.position.x = 0;
                camera.position.y = 7000;
                camera.position.z = 0;
                camera.lookAt( 0, 0, 0);
                break;

            // case 'KeyR':
            //     camera.position.x = -200;
            //     camera.position.y = 100;
            //     camera.position.z = 100;
            //     camera.lookAt( 0, 200, 100);
            //     break;

            // case 'KeyB':
            //     camera.position.x = -2;
            //     camera.position.y = 1;
            //     camera.position.z = -2;
            //     camera.lookAt( 10, 1, 10);
            //     break;

            case 'KeyB':
                // camera.position.x = -10;
                // camera.position.y = -2;
                // camera.position.z = -6;
                camera.position.x = camera.position.y = camera.position.z = -3;
                // // File                                sources  ra_min      ra_max      dec_min     dec_max
                // GaiaSource_376186-377043.csv.fapec  516919   61.877817   92.808166   0.008648    19.464846
                // So somewhere near ra 61.877817, dec 19.464846: Hyades + Aldebaran
                camera.lookAt( 60, 200, 44);

                break;

            case 'KeyX':
                we_want_axes = ! we_want_axes
                if (we_want_axes) {
                    scene.remove( axesHelper)
                    axesHelper = new THREE.AxesHelper( star_max_dist );
                    scene.add( axesHelper );
                } else {
                    scene.remove( axesHelper );
                }

                break;

                
            case 'KeyT':
                tour_active = ! tour_active
                // if (tour_active) controls.unlock();
                console.log(tour_active)
                // tour_update( camera);
                break;

            case 'Space':
                warp_enabled = false;
                break;

            case 'KeyP':
                // stars_filter = 'da_hood'
                // reload_all_stars();
                // Go to the next tour stop
                tour_active = true
                tour_target_index += -1
                console.log( tour_target_index)
                if (tour_target_index < 0) tour_target_index = 0
                tour_stops = []
                break;

            case 'KeyN':
                // stars_filter = 'da_hood'
                // reload_all_stars();
                // Go to the next tour stop
                tour_active = true
                
                tour_target_index += 1
                if (tour_target_index >= tour_targets.length) tour_target_index = 0
                tour_stops = []
                // TODO: Can't get stopping tween panning midway through to work properly...
                // stop_tween = true
                // tour_busy = false
                // tour_object_panning = false
                break;

            case 'KeyM':
                var p = earth_hyades_milkyway_bg
                perspectiveCamera.position.set( p[0], p[1], p[2] )
                perspectiveCamera.lookAt( 0, -50, 0 );
                break;

            case 'KeyZ':
                global_render_load_pause = ! global_render_load_pause
                if (global_render_load_pause)
                    statusline += 'Loading & rendering paused!'
                break;


            
        }
    };

    document.addEventListener( 'keydown', onKeyDown );
    document.addEventListener( 'keyup', onKeyUp );

    reload_all_stars()
}

function toggle_global_sizeAttenuation() {
    var prev_global_sizeAttenuation = global_sizeAttenuation;

    global_sizeAttenuation = ! global_sizeAttenuation;

    var existing_node_multiplier;
    if (! global_sizeAttenuation) {
        global_sizeAttenuation_multiplier = 1;
        existing_node_multiplier = global_sizeAttenuation_multiplier;
    }
    else global_sizeAttenuation_multiplier = 1;

    console.log( "global attentuation", global_sizeAttenuation);
    scene.traverse( function( node ) {
        if ( node instanceof THREE.Points ) {
            node.material.sizeAttenuation = global_sizeAttenuation;
            if (! global_sizeAttenuation) {
                node.material.size = node.material.name * global_sizeAttenuation_multiplier;
            } else {
                node.material.size = node.material.name;
            }
            node.material.needsUpdate = true;
            
        }

    } );
}

function reload_all_stars() {
    // if (stars_filter == prev_stars_filter) {
    //     console.log( 'already watching filter ' + stars_filter)
    //     return 0;
    // }
    
    // if ((stars_filter == 'galactic') && (global_sizeAttenuation == true))
    //     toggle_global_sizeAttenuation();


    // Reset scene
    scene.remove.apply(scene, scene.children);
    labels_loaded = false;
    all_stars = {}
    total_stars_in_scene = 0
    total_cubes_in_scene = 0
    data_set_type = gaia_web_datasets[data_set]
    axes_added = false

    // for (var i = 0; i < 2; i++) available_elements.push( i);

    // Add Sol
    add_stars_to_scene( scene, [
    // [ 1, 1, 1, 1, -3],
    [ 0, 0, 0, 1, 5],
    // [ 5, 5, 5, 0.5, -10],
    // [ 10, 20, 10, 2, -10]
    ])


    if (we_want_axes) {
        scene.remove( axesHelper );
        axesHelper = new THREE.AxesHelper( 100 );
        scene.add( axesHelper );
    }

    // add_cubes_to_scene( scene, [])

    add_nebulae_to_scene( scene, nebula_data)
    
    rendered_sky_elements = []
    console.log('Full data reload should occur automatically now...')

    // rendered_sky_elements = []
    // prev_stars_filter = stars_filter;
    prev_data_set = data_set

    initial_scene_reloaded = true;
}

function load_next_sky_element() {
    // console.log( available_elements);
    var element;
    var all_stars_keys = Object.keys( all_stars)
    // console.log('DEBUG61', all_stars_keys)
    for (var index in available_elements) {
        // element = available_elements[index];
        // From now on elements will just be the numbers 0 to 99
        // so that every data set consists of 100 files
        element = index;

        if (! all_stars_keys.includes(element)) { 
            // console.log( 'Need to load element ' + element)
            // only parse 1 to save resources
            
            if ((! loading_lock) && (! global_render_load_pause)) {
                loadScript( scene, element);
            }
            // add_stars_to_scene( scene, all_stars[ element])
            // rendered_sky_elements.push( element)
            // return 0
        } else {
            // console.log( 'Already loaded: ' + element)
            
        }
    }
}

function load_available_sky_elements() {
    // console.log('DEBUG71', Object.keys(all_stars))
    for (var element in all_stars) {
        if ( ! rendered_sky_elements.includes(element)) { 
            // Reserve this now so there's no parsing going on in parallel
            rendered_sky_elements.push( element)
            
            // console.log( 'Need to parse element ' + element)
            // only parse 1 to save resources
            var total_stars = all_stars[ element].length;
            var num_added
            if (data_set_type == 'cubes') {
                num_added = add_cubes_to_scene( scene, all_stars[ element]);
                total_cubes_in_scene += num_added
            } else  {
                num_added = add_stars_to_scene( scene, all_stars[ element]);
                total_stars_in_scene += num_added
            } 

            // Try to allow garbage collection to kick in else we
            // use way too much memory
            all_stars[ element] = 0;
            // rendered_sky_elements.push( element)
            console.log( "Added " + num_added + '/' 
                + total_stars + ' to 3D scene from element: ' + element 
                + ' (' + rendered_sky_elements.length + ' of ' + available_elements.length + '). '
                + 'Total stars/cubes in scene: ' + total_stars_in_scene.toLocaleString()+'/'+total_cubes_in_scene.toLocaleString());

            // var spin = spinner[ rendered_sky_elements.length + Object.keys(all_stars)]
            var total = rendered_sky_elements.length + Object.keys(all_stars).length
            var spin = spinner [total % 4]
            statusline = 'Loaded/parsed '
                + Object.keys(all_stars).length + '/' + rendered_sky_elements.length 
                + ' of ' + available_elements.length;
            // return 0
        } else {
            // console.log( 'Already parsed: ' + element)
            
        }
        
    }

    if ( (rendered_sky_elements.length == 100) && ! axes_added) {
        // console.log('TEST')
        if (we_want_axes) {
            scene.remove( axesHelper)
            axesHelper = new THREE.AxesHelper( star_max_dist );
            scene.add( axesHelper );
            axes_added = true;
        }

    }
}

function tour_update( camera) {
    // now.getTime();
    // requestAnimationFrame( tour_update( c2) );
    // var right_now = performance.now()

    // console.log('tour busy', tour_busy)

    var easing;
    var easing_time = 5000;
    var orbit_step_size = 0.1;
    if ((tour_active && ! tour_busy && (tour_targets.length > 0)) || (stop_tween)) {
        tour_started = true;
        tour_busy = true;
        var t = icrs_to_threejs( tour_targets[ tour_target_index]);
        tour_target_name = tour_targets[ tour_target_index][3]

        var tour_target_distance = tour_orbit_radius_default
        // increase distance if target is big...like a galaxy maybe ;) 
        if (tour_targets[ tour_target_index].length > 4) {
            tour_target_distance = tour_targets[ tour_target_index][4]
        }

        if (tour_stops.length == 0) {
            easing = TWEEN.Easing.Circular.InOut;


            
            tour_stops = [
                [t[0] - tour_target_distance, t[1], t[2]]
            ]

            /*
            Calculate a nice pseudo fly around orbit. It's not so much an actual orbit
            as it is a step-wise walk around the edges of a circle comprising pizza
            slice triangles. Therefore, flying around stars should now start to 
            make you feel hungry ;).
            */
            
            var xdiff, ydiff, zdiff;
            var cur_radius = tour_target_distance;
            var up_or_down = (Math.random() < 0.5 ? 1 : -1)
            for (var i = orbit_step_size; i < Math.PI * 4; i += orbit_step_size) {
                cur_radius = tour_target_distance + Math.sin(i * 0.2) * 0.6 * tour_target_distance;
                xdiff = t[0] - Math.cos(i) * cur_radius;
                ydiff = t[1] + up_or_down * Math.sin(i * 0.4) * 0.8 * cur_radius;
                zdiff = t[2] + Math.sin(i) * cur_radius;
                tour_stops.push( [xdiff, ydiff, zdiff])
            }
            /*
            // Go around the object along the edges of a cube. Boring and lame.
            tour_stops = [
                [t[0] - tour_orbit_radius, t[1] - tour_orbit_radius, t[2]  - tour_orbit_radius],
                [t[0] + tour_orbit_radius, t[1] - tour_orbit_radius, t[2]  - tour_orbit_radius],
                [t[0] + tour_orbit_radius, t[1] + tour_orbit_radius, t[2]  - tour_orbit_radius],
                [t[0] + tour_orbit_radius, t[1] + tour_orbit_radius, t[2]  + tour_orbit_radius],
                [t[0] - tour_orbit_radius, t[1] + tour_orbit_radius, t[2]  + tour_orbit_radius],
                [t[0] - tour_orbit_radius, t[1] + tour_orbit_radius, t[2]  - tour_orbit_radius],
                [t[0] - tour_orbit_radius, t[1] - tour_orbit_radius, t[2]  - tour_orbit_radius],
            ]
            */

            // Pan camera to new object smoothly
            tour_object_panning = true
            perspectiveCamera.getWorldDirection( camera_vector );
            var angle_from = { 
                x: camera.position.x + camera_vector.x * 1000, 
                y: camera.position.y + camera_vector.y * 1000, 
                z: camera.position.z + camera_vector.z * 1000} 

            var angle_to = { x : t[0], y : t[1], z : t[2] };

            easing = TWEEN.Easing.Linear.None;
            // easing = TWEEN.Easing.Sinusoidal.InOut
            // console.log('ALERT1: start panning')
            var tween = new TWEEN.Tween(angle_from)
            .to( angle_to, 2000)
            .easing( easing)
            // .easing( TWEEN.Easing.Cubic.InOut)
            // .easing( TWEEN.Easing.Linear.None)            
            .onUpdate( function () {
                // console.log( 'ALERT4', camera.position.x, from.x)
                // camera.position.x = this.x;
                // camera.position.set( from.x, from.y, from.z);
                if (tour_busy)
                    camera.lookAt( angle_from.x, angle_from.y, angle_from.z);
                if (stop_tween) {
                    tween.stop()
                    stop_tween = false
                }
            })
            .onComplete( function () {
                // camera.lookAt( t[0], t[1], t[2]);
                // tour_busy = false
                tour_object_panning = false;
            })
            .start();

        } else {
            // Go faster and linear for the semi-circular orbital pizza slices calculated above
            easing = TWEEN.Easing.Linear.None;
            easing_time = 500 * (orbit_step_size / 0.2); // ms

            // easing = TWEEN.Easing.Sinusoidal.InOut; // Was used for cube lookaround

        }
        
        var from = { x: camera.position.x, y: camera.position.y, z: camera.position.z } 

        var ts = tour_stops.shift();
        // console.log('ALERT2', tour_busy, tour_target_index, tour_stops.length, ts)
        
        // start the tween for the camera position
        var to = { x : ts[0], y : ts[1], z : ts[2] };
        var tween = new TWEEN.Tween(from)
            .to( to, easing_time)
            // .easing( TWEEN.Easing.Cubic.InOut)
            .easing( easing)            
            .onUpdate( function () {
                // console.log( 'ALERT4', camera.position.x, from.x)
                // camera.position.x = this.x;
                if (tour_busy) {
                    camera.position.set( from.x, from.y, from.z);
                    if (!tour_object_panning)
                        camera.lookAt( t[0], t[1], t[2]);
                } else return 0;
            })
            .onComplete( function () {
                if (tour_busy) {
                    camera.lookAt( t[0], t[1], t[2]);
                    tour_busy = false
                }
            })
            .start();





        // start the tween for the camera viewing angle
        // TODO

        // tour_index += 1;
        if (tour_stops.length == 0) {
            // Move to next object in tour_targets
            tour_target_index += 1;
            if (tour_target_index == tour_targets.length) {
                // Make tour ready for reuse:
                tour_active = false;
                tour_target_index = 0;
            }
            // tour_busy = false;
            // tour_index = 0; // Will create next tour_stops[] for next tour_targets item.
        }
        statusline = 'Tour: ' + tour_name
        + '\n  stop # ' + (tour_target_index+1)
        + ': ' + tour_target_name
    }
    return 0


}

function onWindowResize() {

    const aspect = window.innerWidth / window.innerHeight;

    perspectiveCamera.aspect = aspect;
    perspectiveCamera.updateProjectionMatrix();

    orthographicCamera.left = - frustumSize * aspect / 2;
    orthographicCamera.right = frustumSize * aspect / 2;
    orthographicCamera.top = frustumSize / 2;
    orthographicCamera.bottom = - frustumSize / 2;
    orthographicCamera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );

    // controls.handleResize(); // not sure what this is/was supposed to do?

}

function zoom_camera( zoom_in) {
 
    // camera = perspectiveCamera;
    var old_fov = perspectiveCamera.fov;
    var new_fov;
    if (zoom_in) {
        new_fov = default_camera_fov / 5
        // perspectiveCamera.zoom = 0.1
    } else {
        new_fov = default_camera_fov
        // perspectiveCamera.zoom = 1
    }
    // perspectiveCamera.updateProjectionMatrix();
    // console.log( perspectiveCamera.fov)

    perspectiveCamera.fov = new_fov
    perspectiveCamera.updateProjectionMatrix();

    // Why doesn't this tween work?
    // var tween = new TWEEN.Tween(old_fov)
    //     .to( new_fov, 1000)
    //     .easing( TWEEN.Easing.Linear.None)
    //     // .easing( TWEEN.Easing.Cubic.InOut)
    //     // .easing( TWEEN.Easing.Linear.None)            
    //     .onUpdate( function () {
    //         // console.log( 'ALERT4', camera.position.x, from.x)
    //         // camera.position.x = this.x;
    //         // camera.position.set( from.x, from.y, from.z);
    //         perspectiveCamera.fov = old_fov
    //         perspectiveCamera.updateProjectionMatrix();
    //     })
    //     // .onComplete( function () {
    //     //     // camera.lookAt( t[0], t[1], t[2]);
    //     //     // tour_busy = false
    //     //     // tour_object_panning = false;
    //     // })
    //     .start();
}

function animate() {
    requestAnimationFrame( animate );

    const time = performance.now();

    camera = perspectiveCamera;
    
    // camera.up.set(0,0,1);

    
    perspectiveCamera.getWorldDirection( camera_vector );

    if (tour_active && !tour_busy) {
        tour_update( camera);
    }
    if (tour_busy) {
        TWEEN.update();
    }


    stats.update();
    // if ( controls.isLocked === true ) {

    // raycaster.ray.origin.copy( controls.getObject().position );
        // raycaster.ray.origin.y -= 10;

        // const intersections = raycaster.intersectObjects( objects, false );

        // const onObject = intersections.length > 0;

    // const delta = ( time - prevTime ) / 1000;
    var delta = 10 / 1000;

    if (warp_enabled) { 
        warp_speed += 0.1;
        if (warp_speed > 10) warp_speed = 9.9;
    } else {
        if (warp_speed > 1) warp_speed -= 0.1;
        if (warp_speed < 1) warp_speed = 1;
    }
    delta = delta * (warp_speed ** 1.5)
    // delta = delta * ((warp_speed/3) ** 2)
    // delta = delta * (warp_speed ** 1.5)
    // console.log( delta)
    

    // velocity.x -= velocity.x * speed_multiplier * delta;
    // velocity.y -= velocity.y * speed_multiplier * delta;
    // velocity.z -= velocity.z * speed_multiplier * delta;

    // velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

    direction.z = Number( moveForward ) - Number( moveBackward );
    if (moveUp || moveDown) direction.y = Number( moveUp) - Number( moveDown );
    else direction.y = camera_vector.y * (Number( moveForward ) - Number( moveBackward ));
    direction.x = Number( moveRight ) - Number( moveLeft );
    direction.normalize(); // this ensures consistent movements in all directions

    if ( moveForward || moveBackward ) velocity.z -= direction.z * 400.0 * delta;
    else velocity.z -= velocity.z * speed_multiplier * delta;
    if ( moveForward || moveBackward || moveUp || moveDown) velocity.y -= direction.y * 400.0 * delta;
    else velocity.y -= velocity.y * speed_multiplier * delta;
    if ( moveLeft || moveRight ) velocity.x -= direction.x * 400.0 * delta;
    else velocity.x -= velocity.x * speed_multiplier * delta;




    // if ( (direction.x != 0) || (direction.y != 0) || (direction.z != 0)) {
    // 	console.log( 'camera: ', camera_vector)
    // 	// console.log( 'direction: ', direction)
    // }
    // if ( (velocity.x != 0) || (velocity.y != 0) || (velocity.z != 0)) {
    // 	console.log( 'camera: ', camera_vector)
    // 	// console.log( 'velocity: ', velocity )
    // }
    // if ( onObject === true ) {

    // 	velocity.y = Math.max( 0, velocity.y );
    // 	canJump = true;

    // }
    var max_velocity = 300;
    if (slow_down_cowboy) max_velocity = max_velocity / 10;

    if (velocity.x > max_velocity) velocity.x = max_velocity;
    if (velocity.y > max_velocity) velocity.y = max_velocity;
    if (velocity.z > max_velocity) velocity.z = max_velocity;
    if (velocity.x < -max_velocity) velocity.x = -max_velocity;
    if (velocity.y < -max_velocity) velocity.y = -max_velocity;
    if (velocity.z < -max_velocity) velocity.z = -max_velocity;

    // if (
    // 	(velocity.x * delta > 10) ||
    // 	(velocity.y * delta > 10) ||
    // 	(velocity.z * delta > 10)) {
    // 		console.log( 'velos', velocity.x * delta, velocity.y * delta, velocity.z * delta);
    // 		console.log( 'delta', delta);

    // 	}
    controls.moveRight( - velocity.x * delta );
    controls.moveUp( - velocity.y * delta );
    controls.moveForward( - velocity.z * delta );
    // controls.moveUp( - velocity.y * delta );

    // controls.getObject().position.y += ( velocity.y * delta ); // new behavior

    // if ( controls.getObject().position.y < 10 ) {

    // 	velocity.y = 0;
    // 	controls.getObject().position.y = 10;

    // 	canJump = true;

    // }

    // }

    prevTime = time;


    // console.log('render now')
    if (! global_render_load_pause)
        renderer.render( scene, camera );

    var tjs_campos = [ camera.position.x, camera.position.y, camera.position.z]
    // convert Three.js cam positions to ICSR coords
    var cam_c = icrs_to_threejs( tjs_campos, true)
    var dist = Math.sqrt( cam_c[0]**2 + cam_c[1]**2 + cam_c[2]**2)

    var deg = Math.asin( cam_c[2] / dist);
    var deg_degrees = deg * 180 / Math.PI;
    var deg_mins = (deg_degrees - Math.floor( deg_degrees)) * 60;

    
    var RA = Math.atan2( cam_c[1], cam_c[0]);
    if (RA < 0) RA = Math.PI * 2 + RA;
    var RA_degrees = RA * 180 / Math.PI;
    var RA_hours = Math.floor( RA_degrees / 15)
    var RA_mins = ((RA_degrees - RA_hours * 15) / 15 * 60)
    var RA_secs = (RA_mins - Math.floor( RA_mins)) * 60;

    var hud_text = 
    '[ Starship data ]\n'
        + 'Position (x,y,z) in ly:\n  ' 
        + cam_c[0].toFixed(2) + ', '
        + cam_c[1].toFixed(2) + ', ' 
        + cam_c[2].toFixed(2) 
        + '\n'
        + 'Earth/Sol distance:\n  '
        + dist.toFixed(2) + ' ly =~ '
        + (dist/lightyear_p_parsec).toFixed(2) + ' pc '
        + '\n'
        + 'Earth/Sol coords:\n'
        + '  RA: ' + parseInt(RA_hours) + 'h' 
        + parseInt(RA_mins) + 'm ' 
        + RA_secs.toFixed(1) + 's'
        + '\n'
        + '  dec: ' + (deg_degrees > 0 ? '+':'') + parseInt(deg_degrees)
        + 'Â°'+ deg_mins.toFixed(1) + "â€²"
        + '\n'
        + 'Camera angle vector (x,y,z):\n  '
        + camera_vector.x.toFixed(2) + ', ' 
        + camera_vector.y.toFixed(2) + ', ' 
        + camera_vector.z.toFixed(2)
        + '\nData set:\n' 
        + '   ' + data_set + ' (' + data_set_type + ')'
        + '\nTotal stars/cubes in scene:\n  ' 
        + total_stars_in_scene.toLocaleString()+'/'+total_cubes_in_scene.toLocaleString()
    
        if (slow_down_cowboy)
            hud_text += '\nSlowdown activated (L to toggle)'
        
        hud_text += '\n' + statusline
        ;
        document.getElementById('statusline').innerText = hud_text;



}

function render() {

    // const camera = ( params.orthographicCamera ) ? orthographicCamera : perspectiveCamera;
    // const camera = ( params.orthographicCamera ) ? orthographicCamera : perspectiveCamera;

    // delta += clock.getDelta();

//    if (delta  > interval) {
//        // The draw or time dependent code are here
//     //    render();
//        renderer.render( scene, camera );

//        delta = delta % interval;
//    }

    renderer.render( scene, perspectiveCamera );

}

// Now you can get back to yer silly tidy XML based indentation, hah!
		</script>
	</body>
</html>
