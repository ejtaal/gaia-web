<!DOCTYPE html>
<html lang="en">
	<head>
		<title>GAIA-Web 3D Starfield v0.21</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="three.js/main.css">
		<style>
			body {
				background-color: #ccc;
				color: #000;
			}
			a {
				color: #f00;
			}
			#statusline {
				position: absolute;
                left: 0px;
                bottom: 0px;
				width: auto;
				height: auto;
				color: greenyellow;
				background-color: rgba(0,0,0,0.4);

				display: flex;
				flex-direction: row;
				justify-content: left;
				/* align-items: center; */

				text-align: left;
                margin: 0;
                padding: 5px;
                line-height: 100%;
				font-size: 12px;
				/* cursor: pointer; */
				border: 1px solid green;

			}
			#blocker {
				position: absolute;
				width: 100%;
				height: 100%;
				color: white;
				background-color: rgba(0,0,0,0.1);
			}

			#instructions {
				width: 100%;
				height: 100%;

				display: flex;
				flex-direction: column;
				justify-content: left;
				align-items: left;

                line-height: 100%;
				text-align: left;
				font-size: 12px;
				cursor: pointer;
				border: 3px solid white;
			}			
		</style>
	</head>

	<body>
		<div id="blocker">
			<div id="instructions">
				<p style="font-size:16px">
<pre>



Welcome to Gaia-web, where you can fly through the 
stars like the USS Enterprise :)

Where pressing space finally gets you into space :)

Please be patient as star data is loaded in the background.

   Click here to start ...
</pre>
				</p>
				<p> Keyboard shortcuts: <br/>
					Move: WASDQE<br/>
					Warp: Space<br/>
					Look: Mouse<br/>
					Toggle distance dimming: T<br/>
                    Back to Sol: B<br/>
                    Galactic overview: G<br/>
                    Planet Earth/Sol/Origin: P<br/>
                    Reload all star data for galactic overview: L<br/>
                    Reload all star data for Sol neighbourhood:Planet Earth/Sol/Origin: N<br/>
				</p>
			</div>
		</div>
		<pre id="statusline"></pre>
		<!-- 
		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - trackball controls<br />
			MOVE mouse &amp; press LEFT/A: rotate, MIDDLE/S: zoom, RIGHT/D: pan
		</div>
			<script type="text/javascript" src="./stars-test-01.js"></script>
    		<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
		 -->
		
		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="./libs/es-module-shims.js"></script>
        <script src="./libs/tween.umd.js"></script>


		<script type="importmap">
			{
				"imports": {
					"three": "./three.js/build/three.module.js",
					"three/addons/": "./three.js/jsm/",
					"local-data/": "./data/"
				}
			}
		</script>
		<script type="x-shader/x-vertex" id="vertexshader">

			attribute float size;
			attribute vec3 customColor;

			varying vec3 vColor;

			void main() {

				vColor = customColor;

				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

				gl_PointSize = size * ( 300.0 / -mvPosition.z );

				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">

			uniform vec3 color;
			uniform sampler2D pointTexture;

			varying vec3 vColor;

			void main() {

				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );

			}

		</script>
		<!-- The main index of all sky patch elements, which basically based on this file:
            http://cdn.gea.esac.esa.int/Gaia/gdr3/gaia_source/_MD5SUM.txt
         -->
        <script type="text/javascript" src="data/gaia-web-sky-elements.js"></script>
        <script type="module">
// Uhm yeah the HTML ain't gonna dictate our indentation. Who does it think it is!?!?
import * as THREE from 'three';

import Stats from 'three/addons/libs/stats.module.js';
import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

// import { TrackballControls } from 'three/addons/controls/TrackballControls.js';

import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

// Courtesy of: https://codepen.io/hootstheowl/pen/xOQVQg
// class CubeWebGL {
//   constructor(props = {}) {
//     Object.assign(this, {
//       // set variable settings
//       container: props.container || document.body,
//       fps: props.fps || 30,
//       theta: props.theta || 0.1,
//       radius: props.radius || 600,
//       opacity: props.opacity || 0.2,
//       count: props.count || 150,
//       palette: props.palette || null,
//       // containers for ThreeJS animation
//       then: Date.now(),
//       camera: null,
//       scene: null,
//       renderer: null,
//     });
//     // // let's go!
//     // this.init();
//     // this.animate();
//     // document.addEventListener(
//     //   'mousedown', this.getIntersect.bind(this), false
//     // );
//   }
//   getIntersect(e) {
//     const raycaster = new THREE.Raycaster();
//     const mouse = new THREE.Vector3();
//     mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
// 	  mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
//     // update the picking ray with the camera and mouse position	
// 	  raycaster.setFromCamera( mouse, this.camera );	
//     // calculate objects intersecting the picking ray
//     const intersects = raycaster.intersectObjects( this.scene.children );
//     console.log(intersects)
//   }
//   addCube() {
//     const { palette, opacity } = this;
//     if (Array.isArray(palette)) {
//       const cubeColor = palette[Math.floor(
//         Math.random() * palette.length
//       )];
//     }
//     const cube = new THREE.Mesh(
//       new THREE.BoxGeometry(2.5, 2.5, 2.5),
//       new THREE.MeshBasicMaterial({
//         color: Math.random() * 0x808008 + 0x808080,
//         transparent: true,
//         opacity,
//       })
//     );
//     cube.position.x = this.generatePosition();
//     cube.position.y = this.generatePosition();
//     cube.position.z = this.generatePosition();
//     cube.scale.x= cube.scale.y = cube.scale.z = Math.random() * 45;
//     this.scene.add(cube);
//   }







let data_set = 'star_density'
let prev_data_set = 'star_density'
let data_set_type = 'cubes'
let data_set_xyz_multiplier = 100

let moveForward = false;
let moveBackward = false;
let moveLeft = false;
let moveRight = false;
let moveUp = false;
let moveDown = false;
let canJump = false;
let warp_speed = 1;
let warp_enabled = false;
let global_sizeAttenuation = true;
let global_sizeAttenuation_multiplier = 1;

let stars_filter = 'da_hood';
// let stars_filter = 'galactic';
let prev_stars_filter = ''; // Set to empty to force reload @ reload_all_stars() call

let tour_active = false;
let tour_speed = 0;
let tour_target_arrived = false;
let tour_time_at_target = 0;
let tour_prev_update = 0;
let tour_orbit_radius = 25; //ly
let tour_targets = [
    /*
    */
    [  62, 130,   50],
    [ 489, 730,  553],
    [ -366, 434, 203],
    [ 515, 340, 1055],
    [ 907, 779, 1102],
    [ 125, 1219, -130],
    [ 144.4, 1113.5, 53.8 ],
    [ -266.2, 1239.2,1100.6 ],
    [ -2176.2, -4843.8, -2653.4 ],
    [ 3618.0, 2559.1, 6839.6 ], // Maybe globular cluster?
    /*
    [ ],
    [ ],
    [ ],
    [ ],
    */
    ];

let tour_orbit_angle = 0;
let tour_orbit_dec = 0;
let tour_orbit_start_x;
let tour_orbit_start_y;
let tour_orbit_start_z;
let tour_orbit_insertion_distance;
let tour_orbit_insertion_speed;
let tour_orbit_target;
let tour_started = false;
let tour_stops = [];
let tour_target_index = 0;
let tour_busy = false;
let tour_object_panning = true;

let prevTime = performance.now();
const velocity = new THREE.Vector3();
const direction = new THREE.Vector3();
const vertex = new THREE.Vector3();
const camera_vector = new THREE.Vector3();
const color = new THREE.Color();
let initial_scene_reloaded = false;


const sprite = new THREE.TextureLoader().load( 'three.js/textures/sprites/disc.png' );

let camera, perspectiveCamera, orthographicCamera, controls, scene, renderer, stats;

const params = {
    orthographicCamera: false,
    'option 1': false,
    'option 2': true
};

const frustumSize = 400;
var star_max_dist = 10**5;
var star_max_dist = 10**3;
var all_stars = {};
var rendered_sky_elements = [];
var total_stars_in_scene = 0;
var total_cubes_in_scene = 0;

var loading_lock = false;

var speed = 0
var speed_multiplier = 10.0	// 5.0
var lightyear_p_parsec = 3.261563777

init();
animate();

function add_nebulae_to_scene( scene, nebulae_data) {

    var canvas = document.createElement("canvas");

    var pic = new Image(); 
    pic.src = 'nebulae/out.png'; 
    pic.onload = function() {

        canvas.width = pic.width;
        canvas.height = pic.height;
        var ctx = canvas.getContext("2d");

        ctx.drawImage(pic, 0, 0);

        var c = canvas.getContext('2d');
        var p = c.getImageData(107, 107, 1, 1).data;
        var hex = "RGB = " + p[0]+", "+p[1]+", "+p[2];
        console.log( 'colors: ', p, hex)

        var p = c.getImageData( 80, 80, 1, 1).data;
        var hex = "RGB = " + p[0]+", "+p[1]+", "+p[2];
        console.log( 'colors: ', p, hex)

        // Transform image to cubes
        var pixel
        for (var y = 1; y < pic.height; y++) {
            for (var z = 1; z < pic.width; z++) {
                    var cube = new THREE.Mesh(
                    new THREE.BoxGeometry( 1, 1, 1),
                    new THREE.MeshBasicMaterial({
                        // color: Math.random() * 0x0000FF, // + 0x000080,
                        color: 0x0000FF,
                        // color: 0x8888AA,
                        transparent: true,
                        // opacity: Math.random() * 0.1,
                        opacity: 0.1,
                    })
                    );
                    cube.position.x = 50
                    cube.position.y = 50 + pic.height - y
                    cube.position.z = 100 + z
                    // cube.material.opacity = 0.3
                    // cube.material.color = Math.random() * 0x000080 + 0x606080,
                    // cube.material.color = new THREE.Color()
                    cube.material.opacity = 0.3; // * (x+y+z)/30
                    pixel = c.getImageData( z, y, 1, 1).data;
                    // var hex = "RGB = " + p[0]+", "+p[1]+", "+p[2];
                    cube.material.color.setRGB( pixel[0] / 256, pixel[1] / 256, pixel[2] / 256) // + 0x000080,
                    // cube.scale.x= cube.scale.y = cube.scale.z = Math.random();
                    // console.log('cube: ', cube)
                    scene.add(cube);

                    // Add depth cubes
                    var depth = parseInt( 0.25 * pic.width * (pixel[0] + pixel[1] + pixel[2]) / (256 * 3))
                    var dimm_factor = 1;
                    for (var x = -depth; x < depth; x++) {
                        var cube = new THREE.Mesh(
                        new THREE.BoxGeometry( 1, 1, 1),
                        new THREE.MeshBasicMaterial({
                            // color: Math.random() * 0x0000FF, // + 0x000080,
                            color: 0x0000FF,
                            // color: 0x8888AA,
                            transparent: true,
                            // opacity: Math.random() * 0.1,
                            opacity: 0.1,
                        })
                        );
                        cube.position.x = 50 + x
                        cube.position.y = 50 + pic.height - y
                        cube.position.z = 100 + z
                        dimm_factor = (1 - Math.abs( x / depth))
                        cube.material.opacity = 0.3 * dimm_factor
                        // pixel = c.getImageData( z, y, 1, 1).data;
                        // var hex = "RGB = " + p[0]+", "+p[1]+", "+p[2];
                        cube.material.color.setRGB( pixel[0] / 256, pixel[1] / 256, pixel[2] / 256) // + 0x000080,
                        // cube.scale.x= cube.scale.y = cube.scale.z = Math.random();
                        // console.log('cube: ', cube)
                        scene.add(cube);

                    }


            
            }
        }    
}
    // document.getElementById("output").innerHTML = hex; 




    // let img = new (window as any).Image();
    // img.crossOrigin = `Anonymous`;

    // img.src = "nebulae/out.png";
    // img.onload = function () {
    //     canvas = document.getElementById("myCanvas") as HTMLCanvasElement;
    //     canvas.width = img.width;
    //     canvas.height = img.height;
    //     let ctx: CanvasRenderingContext2D = canvas.getContext(
    //         "2d"
    //     ) as CanvasRenderingContext2D;
    //     ctx.drawImage(img, 0, 0);

    //     const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    //     data = imgData.data;
    //     canvas.addEventListener("mousemove", (ev) => {
    //         //as the mouse moves around the image
    //         let cols = canvas.width;
    //         let { offsetX, offsetY } = ev;
    //         //call the method to get the r,g,b,a values for current pixel
    //         let c = extractPixelColor(cols, offsetY, offsetX);
    //         //build a colour string for 
    //         let colour = `rgb(${c.red}, ${c.green}, ${c.blue})`} ;
    //         let hexCode = `#${[c.red, c.green, c.blue]
    //             .map((x) => x.toString(16).padStart(2, "0"))
    //             .join("")}`;
            
    //     });
    // };


}


function add_cubes_to_scene( scene, cube_data) {
    /*
    theta: props.theta || 0.1,
      radius: props.radius || 600,
      opacity: props.opacity || 0.2,
      count: props.count || 150,
      palette: props.palette || null,
    //   */  
    //   const { palette, opacity } = this;
    // if (Array.isArray(palette)) {
    //   const cubeColor = palette[Math.floor(
    //     Math.random() * palette.length
    //   )];
    // }

    // const cube = new THREE.Mesh(
    //   new THREE.BoxGeometry( 50, 50, 50),
    //   new THREE.MeshBasicMaterial({
    //     // color: Math.random() * 0x000080 + 0x808080,
    //     color: 0x8888AA,
    //     transparent: true,
    //     opacity: 0.2,
    //   })
    // );


    // console.log( cube_data)
    var c;
    var x, y, z;
    var actually_added = 0;
    for (var cube_idx = 0; cube_idx < cube_data.length; cube_idx++) {
        // var cube = new THREE.Mesh(
        //     // new THREE.BoxGeometry( 49, 49, 49),
        //     new THREE.BoxGeometry( 1* data_set_xyz_multiplier, 1* data_set_xyz_multiplier, 1* data_set_xyz_multiplier),
        //     new THREE.MeshBasicMaterial({
        //     // color: Math.random() * 0x0000FF, // + 0x000080,
        //     color: 0x8888AA,
        //     // transparent: true,
        //     // opacity: Math.random() * 0.1,
        //     wireframe: true,
        //     // opacity: 0.1,
        // })
        // );
        // // Values were rounded, so move down each axis by half
        // x = (cube_data[ cube_idx][0] - 0.5) * data_set_xyz_multiplier
        // y = (cube_data[ cube_idx][1] - 0.5) * data_set_xyz_multiplier
        // z = (cube_data[ cube_idx][2] - 0.5) * data_set_xyz_multiplier
        // c = cube_data[ cube_idx][3]
        // if (c < 0.05) continue;
        // actually_added++;
        // cube.position.x = x
        // cube.position.y = y
        // cube.position.z = z
        // cube.material.color.setRGB( c, c, c)
        // scene.add(cube);

        // var dotGeometry = new THREE.BufferGeometry();
        // dotGeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( 
        //     [ x, y, z], 3 
        // ) );
        // var dotMaterial = new THREE.PointsMaterial( { size: 0.3  * data_set_xyz_multiplier, color: 0x00ff00 } );
        // dotMaterial.color.setRGB( c, c, c)
        // var dot = new THREE.Points( dotGeometry, dotMaterial );
        // scene.add( dot );

        // cube.material.opacity = 0.3
        // cube.material.color = Math.random() * 0x000080 + 0x606080,
        // cube.material.color = new THREE.Color()
        // cube.material.opacity = 0.3 * (x+y+z)/30
        //, // + 0x000080,

    }

    var stars_geometry = new THREE.BufferGeometry();
    var amount = cube_data.length
    const positions = new Float32Array( amount * 3 );
    const colors = new Float32Array( amount * 3 );
    const sizes = new Float32Array( amount);    
    
    // const color = new THREE.Color( 0xff00ff );
    for (var i = 0; i < amount; i++) {
        x = (cube_data[ i][0] - 0.5) * data_set_xyz_multiplier
        y = (cube_data[ i][1] - 0.5) * data_set_xyz_multiplier
        z = (cube_data[ i][2] - 0.5) * data_set_xyz_multiplier
        c = cube_data[  i][3]
        positions[i*3+0] = x
        positions[i*3+1] = y
        positions[i*3+2] = z
        colors[i*3+0] = c
        colors[i*3+1] = c
        colors[i*3+2] = c
        
        // positions[i*3+1] = bucket['positions'][i][1];
        // positions[i*3+2] = bucket['positions'][i][2];
        // console.log( 'ALERT 5', amount, bucket['positions'][i], positions[i*3], bucket['positions'][i][0])
        // color.toArray( colors, i * 3 );
        // colors.push( c * 256, c * 256, c * 256)
        sizes[i] = (c**2) * data_set_xyz_multiplier * 20
    }    
    
    // for (var i = 0; i < cube_data.length; cube_idx++) sizes[i] = cube_data[ i][3] * data_set_xyz_multiplier / 2

    // for (var i = 0; i < amount; i++) sizes[i] = size;
    stars_geometry.setAttribute( 'size', new THREE.BufferAttribute( sizes, 1 ) );
    stars_geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
    stars_geometry.setAttribute( 'customColor', new THREE.BufferAttribute( colors, 3 ) );

    const point_material = new THREE.ShaderMaterial( {
        uniforms: {
            color: { value: new THREE.Color( 0xffffff ) },
            // pointTexture: { value: new THREE.TextureLoader().load( 'three.js/textures/sprites/spark1.png' ) }
            // https://www.cleanpng.com/png-sparkling-star-download-light-302543/download-png.html
            pointTexture: { value: new THREE.TextureLoader().load( 'images/star-glare6.png' ) }

        },
        vertexShader: document.getElementById( 'vertexshader' ).textContent,
        fragmentShader: document.getElementById( 'fragmentshader' ).textContent,

        blending: THREE.AdditiveBlending,
        depthTest: false,
        transparent: true,
        vertexColors : true
        // flatShading: true

    } );

    var points = new THREE.Points( stars_geometry, point_material );
    scene.add( points );
    return amount;
    
    // return actually_added;
    // for (var y = 1; y < 10; y++) {
    //     for (var x = 1; x < 10; x++) {
    //         for (var z = 1; z < 10; z++) {
    //             var cube = new THREE.Mesh(
    //                 // new THREE.BoxGeometry( 49, 49, 49),
    //                 new THREE.BoxGeometry( 50, 50, 50),
    //                 new THREE.MeshBasicMaterial({
    //                 color: Math.random() * 0x0000FF, // + 0x000080,
    //                 // color: 0x8888AA,
    //                 // transparent: true,
    //                 // opacity: Math.random() * 0.1,
    //                 wireframe: true,
    //                 // opacity: 0.1,
    //             })
    //             );
    //             cube.position.x = x * 50 + 100
    //             cube.position.y = y * 50
    //             cube.position.z = z * 50
    //             // cube.material.opacity = 0.3
    //             // cube.material.color = Math.random() * 0x000080 + 0x606080,
    //             // cube.material.color = new THREE.Color()
    //             // cube.material.opacity = 0.3 * (x+y+z)/30
    //             cube.material.color.setRGB( ((30 - (x+y+z))/30)**4, ((10-z)/10)**4, ((x+y+z)/30)**4), // + 0x000080,
    //             // cube.scale.x= cube.scale.y = cube.scale.z = Math.random();
    //             // console.log('cube: ', cube)
    //             scene.add(cube);
    //         }
        
    //     }
    // }
}


function add_stars_to_scene( scene, star_coords) {
    const positions = [];
    const size_buckets = {};
    
    var colors = [];
    var color_array = [];
    var veff_color = 0;
    var Wavelength = 0;
    var Red = 0;
    var Green = 0;
    var Blue = 0;
    var Teff = 0;
    const color = new THREE.Color();

    // console.log( star_coords.length);
    // // console.log( star_colors.length);
    // console.log( star_coords[star_coords.length-1]);

    var apparent_magnitude = 10;
    var dimming_factor = 1;
    var temperature = 0;
    var red, green, blue;
    var distance;
    var abs_magnitude;
    var x, y, z;
    var temperature_fudge_factor = 1.4;

    for ( var i = 0; i < star_coords.length; i += 1) {

        x = star_coords[i][0];
        y = star_coords[i][1];
        z = star_coords[i][2];
        veff_color = star_coords[i][3];
        abs_magnitude = star_coords[i][4];

        // TODO: Add filtering based on GUI options selected
        distance = Math.sqrt( x**2 + y**2 + z**2)
        
        // if (distance > 2500) continue;
        if ( stars_filter == 'da_hood')
            if ((distance > 3000) || (abs_magnitude > 5)) continue;

        if ( stars_filter == 'galactic')
            if ((distance > 70000) || (abs_magnitude > -3)) continue;
        // if ((distance < 3000) || (distance > 70000) || (abs_magnitude > -5)) continue;
        // if (distance < 2000) continue;

        /*
        Quick absolute magnitude bucket check from a single source file
        3 -9
        9 -8
        34 -7
        111 -6
        459 -5
        1516 -4
        4407 -3
        9748 -2
        17694 -1
        30381 -0
        40426 0
        43501 1
        40873 2
        36897 3
        31345 4
        24082 5
        14950 6
        7328 7
        2546 8
        589 9
        72 10
        5 11
        */

        /*
        // Aim to make the stars between 0.2 and 3 in size to ensure reasonable
        // spread over the absolute magitude bucket sized above
        var star_size = parseInt( 20 - (parseInt(abs_magnitude) + 10)) / 5
        if (star_size > 3) star_size = 3;
        if (star_size < 0.2) star_size = 0.2;
        */
        // With the shader material it's better to make it size 0 - 10
        // spread over the absolute magitude bucket sized above
        var star_size = (10 - parseInt(abs_magnitude)) / 2
        if (star_size > 10) star_size = 10;
        if (star_size < 0.2) star_size = 0.2;

        // initialize bucket if needed:
        if ( ! (star_size in size_buckets)) {
            // console.log( 'Need to create bucket: ' + star_size)
            size_buckets[ star_size] = {
                positions: [],
                colors: []
            }
        }
        
        size_buckets[ star_size]['positions'].push( x, y, z);
        if (distance > star_max_dist) star_max_dist = distance;


        // Dim the brightness of the RGB values further according to magnitude
        dimming_factor = ((900 - ((abs_magnitude+8)**2)) / 900)
        
        if (dimming_factor > 1) dimming_factor = 1;
        if (dimming_factor < 0.1) dimming_factor = 0.1;

        if (veff_color == 0) { color.setRGB( 1, 1, 1) }
        else {
            // νeff, in μm−1
            // veff -> rgb: https://stackoverflow.com/questions/1472514/convert-light-frequency-to-rgb
            // Teff -> rgb: https://www.npmjs.com/package/color-temperature?activeTab=code

            // Wavelength = 1 / (veff_color * 10**-3)

            // For some reason 90% of stars come out red, so apply a fudge
            // factor. TODO: Find out how grown-ups calculate it properly
            Teff = 2.8977719 * veff_color * 1000 * temperature_fudge_factor

            // Calculate RGB values according to Teff 
            temperature = Teff / 100.0;

            // Red
            if (temperature <= 66.0) {
                red = 255;
            } else {
                red = temperature - 60.0;
                red = 329.698727446 * Math.pow(red, -0.1332047592);
                if (red < 0) red = 0;
                if (red > 255) red = 255;
            }

            /* Calculate green */
            if (temperature <= 66.0) {
                green = temperature;
                green = 99.4708025861 * Math.log(green) - 161.1195681661;
                if (green < 0) green = 0;
                if (green > 255) green = 255;
            } else {
                green = temperature - 60.0;
                green = 288.1221695283 * Math.pow(green, -0.0755148492);
                if (green < 0) green = 0;
                if (green > 255) green = 255;
            }

            /* Calculate blue */
            if (temperature >= 66.0) {
                blue = 255;
            } else {
                if (temperature <= 19.0) {
                    blue = 0;
                } else {
                    blue = temperature - 10;
                    blue = 138.5177312231 * Math.log(blue) - 305.0447927307;
                    if (blue < 0) blue = 0;
                    if (blue > 255) blue = 255;
                }
            }

            // console.log( Wavelength)
            // if (i % 100000 == 0) { 
            // 	console.log( apparent_magnitude, dimming_factor, Teff, red, green, blue) 
            // 	console.log( red*dimming_factor/255, green*dimming_factor/255, blue*dimming_factor/255);
            // }
            color.setRGB( red*dimming_factor/255, green*dimming_factor/255, blue*dimming_factor/255);
        }
        size_buckets[ star_size]['colors'].push( color.r, color.g, color.b );
    };

    // add all computed buckets to the scene
    var stars_geometry;
    var total_added = 0;
    // console.log( 'size bucket keys: ', Object.keys(size_buckets))
    for (const [size, bucket] of Object.entries(size_buckets)) {
        // console.log(size, bucket);
    
        stars_geometry = new THREE.BufferGeometry();
        // stars_geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( bucket['positions'], 3 ) );
        // stars_geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( bucket['colors'], 3 ) );
        var amount = bucket['positions'].length
        const positions = new Float32Array( amount * 3 );
        const colors = new Float32Array( amount * 3 );
        const color = new THREE.Color( 0xff00ff );
        for (var i = 0; i < amount; i++) {
            positions[i] = bucket['positions'][i];
            // positions[i*3+1] = bucket['positions'][i][1];
            // positions[i*3+2] = bucket['positions'][i][2];
            // console.log( 'ALERT 5', amount, bucket['positions'][i], positions[i*3], bucket['positions'][i][0])
            // color.toArray( colors, i * 3 );
            colors[i] = bucket['colors'][i]
        }
        
        stars_geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
        stars_geometry.setAttribute( 'customColor', new THREE.BufferAttribute( colors, 3 ) );
        // var sizes = Array( bucket['positions'].length).fill( size)
        const sizes = new Float32Array( amount);
        // for (var i = 0; i < amount; i++) sizes[i] = size * 3;
        for (var i = 0; i < amount; i++) sizes[i] = size;
        stars_geometry.setAttribute( 'size', new THREE.BufferAttribute( sizes, 1 ) );

        const point_material = new THREE.ShaderMaterial( {
            uniforms: {
                color: { value: new THREE.Color( 0xffffff ) },
                // pointTexture: { value: new THREE.TextureLoader().load( 'three.js/textures/sprites/spark1.png' ) }
                // https://www.cleanpng.com/png-sparkling-star-download-light-302543/download-png.html
                pointTexture: { value: new THREE.TextureLoader().load( 'images/star-glare6.png' ) }

            },
            vertexShader: document.getElementById( 'vertexshader' ).textContent,
            fragmentShader: document.getElementById( 'fragmentshader' ).textContent,

            blending: THREE.AdditiveBlending,
            depthTest: false,
            transparent: true,
            vertexColors : true
            // flatShading: true

        } );

        /*
        Since custom properties apparently don't stick, we instead 
        appropiate .name for the original size, as we need to 
        increase/descrease size on the fly when toggling 
        the .sizeAttenuation property.
        */
        // const point_material = new THREE.PointsMaterial( { 
        //     size: size * global_sizeAttenuation_multiplier, 
        //     name: size,
        //     sizeAttenuation: global_sizeAttenuation, map: sprite, 
        //     alphaTest: 0.5, transparent: false, vertexColors: true 
        // } );

        var points = new THREE.Points( stars_geometry, point_material );
        scene.add( points );

        // console.log( bucket)
        // for (var l = 0; l < bucket['positions'].length; l++) {
        //     const light = new THREE.PointLight( bucket['colors'][l], size * 3, size * 100);
		// 			// light.color.setHSL( h, s, l );
		// 			light.position.set( 
        //                 bucket['positions'][l][0],
        //                 bucket['positions'][l][1],
        //                 bucket['positions'][l][2]
        //             );
		// 			scene.add( light );
        // }

        total_added += bucket['positions'].length;
        // console.log('DEBUG1 Added size/# new stars: ', size, bucket['positions'].length)
    }
    // console.log('DEBUG1', star_max_dist)
    // console.log('Added # new stars to scene: ', total_added);

    const axesHelper = new THREE.AxesHelper( star_max_dist );
    scene.add( axesHelper );
    return total_added;
}

// Based on SO answers pointing to most recent JS standards and usage. What do I know.
function loadScript (scene, sky_element, async = false, type = "text/javascript") {
	// var filename = './data/' + sky_element + '.js';
    // New data set format:
    // url: data/set-star_density/8.js

	var filename = './data/set-' + data_set + '/' + sky_element + '.js';
	var FILE_URL = filename;

	if (loading_lock) {
		// Try again next time
		// return 0
	}
	loading_lock = true;

    return new Promise((resolve, reject) => {
        try {
            const scriptEle = document.createElement("script");
            scriptEle.type = type;
            scriptEle.async = async;
            scriptEle.src = FILE_URL;

            scriptEle.addEventListener("load", (ev) => {
                resolve({ status: true });
                // Add the data to all_stars[] where it will be checked and read from later
				// all_stars[sky_element] = stars;
				all_stars[sky_element] = data;
				loading_lock = false;

                var num_loaded = Object.keys( all_stars).length;
                var total = available_elements.length
				console.log("Parsed file " + num_loaded + ' of ' + total
                    + ' (' + sky_element + '): #'
                    + all_stars[sky_element].length + " " + data_set_type + "' data loaded.");
                


				// add_stars_to_scene( scene, stars)
				// console.log('DEBUG3', star_max_dist)
				// console.log('DEBUG32', Object.keys(all_stars))
				// console.log('DEBUG33 loading lock', loading_lock)
				load_next_sky_element()
            });

            scriptEle.addEventListener("error", (ev) => {
                reject({
                    status: false,
                    message: `Failed to load the script ` + FILE_URL
                });
				loading_lock = false;
            });

            document.body.appendChild(scriptEle);
        } catch (error) {
            reject(error);
			loading_lock = false;
        }
    });
};


function init() {

    const aspect = window.innerWidth / window.innerHeight;

    scene = new THREE.Scene();

    var far_away = 10**6
    perspectiveCamera = new THREE.PerspectiveCamera( 60, aspect, 1, far_away );
    perspectiveCamera.position.x = -200;
    perspectiveCamera.position.y = 100
    perspectiveCamera.position.z = 100;

    perspectiveCamera.lookAt( 200, 100, 100 );

    orthographicCamera = new THREE.OrthographicCamera( frustumSize * aspect / - 2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, 1, star_max_dist );
    // orthographicCamera.position.x =
    // orthographicCamera.position.y =
    // orthographicCamera.position.z = 10000;

    // world

    // scene.background = new THREE.Color( 0xcccccc );
    // scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );

    // const geometry = new THREE.CylinderGeometry( 0, 10, 30, 4, 1 );
    // const material = new THREE.MeshPhongMaterial( { color: 0xffffff, flatShading: true } );

    // for ( let i = 0; i < 500; i ++ ) {

    // 	const mesh = new THREE.Mesh( geometry, material );
    // 	mesh.position.x = ( Math.random() - 0.5 ) * 1000;
    // 	mesh.position.y = ( Math.random() - 0.5 ) * 1000;
    // 	mesh.position.z = ( Math.random() - 0.5 ) * 1000;
    // 	mesh.updateMatrix();
    // 	mesh.matrixAutoUpdate = false;
    // 	scene.add( mesh );

    // }

    // // lights

    // const dirLight1 = new THREE.DirectionalLight( 0xffffff );
    // dirLight1.position.set( 1, 1, 1 );
    // scene.add( dirLight1 );

    // const dirLight2 = new THREE.DirectionalLight( 0x002288 );
    // dirLight2.position.set( - 1, - 1, - 1 );
    // scene.add( dirLight2 );

    // const ambientLight = new THREE.AmbientLight( 0x222222 );
    // scene.add( ambientLight );

    // renderer

    renderer = new THREE.WebGLRenderer( { antialias: true } );
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );

    stats = new Stats();
    document.body.appendChild( stats.dom );


    // load_file('7gaiasources');
    // loadJS( scene, '7gaiasources', false);
    // loadJS( scene, 'GaiaSource_005264-006601', false);
    // loadJS( scene, 'GaiaSource_003112-005263', false);


    // console.log('DEBUG2', star_max_dist)
    // console.log('DEBUG2', Object.keys(all_stars))

    const axesHelper = new THREE.AxesHelper( star_max_dist );
    scene.add( axesHelper );



    var rendered_sky_elements = []

    const interval1 = setInterval(function() {
        // method to be executed;
        // console.log( 'DEBUG4: ', Date())
        load_available_sky_elements()
    }, 2000);

    const interval2 = setInterval(function() {
        // method to be executed;
        // console.log( 'DEBUG5: ', Date())
        // console.log('DEBUG51 loading lock', loading_lock)

        if (! loading_lock && initial_scene_reloaded) load_next_sky_element();
    }, 2000);

    const interval3 = setInterval(function() {
        // method to be executed;

        var hash_value_here = 
            + camera_vector.x.toFixed(1) + ',' 
            + camera_vector.y.toFixed(1) + ',' 
            + camera_vector.z.toFixed(1) + '_'
            + camera.position.x.toFixed(1) + ','
            + camera.position.y.toFixed(1) + ',' 
            + camera.position.z.toFixed(1) 
        location.replace("#" + hash_value_here);

    }, 2000);

    const gui = new GUI();

    // TODO: build gui option for each params option

    gui.add( params, 'option 1' ).name( 'Disable distance dimming (sizeAttentuation)' ).onChange( function ( value ) {

        // controls.dispose();

        // createControls( value ? orthographicCamera : perspectiveCamera );
        // alert('hi')
        // To set items still loading in right
        global_sizeAttenuation = value ? false : true;
        // console.log( "global attentuation", global_sizeAttenuation);

        scene.traverse( function( node ) {
            if ( node instanceof THREE.Points ) {
                // console.log( "toggling attentuation", node.material.sizeAttenuation)
                // insert your code here, for example:
                // console.log( node);
                node.material.sizeAttenuation = global_sizeAttenuation;
                node.material.needsUpdate = true;
            }

        } );
    } );

// function toggle_global_sizeAttenuation

    gui.add( params, 'orthographicCamera' ).name( 'use orthographic' ).onChange( function ( value ) {

        // controls.dispose();

        // createControls( value ? orthographicCamera : perspectiveCamera );

    } );

    //

    window.addEventListener( 'resize', onWindowResize );

    // createControls( perspectiveCamera );



    // camera = perspectiveCamera

    controls = new PointerLockControls( perspectiveCamera, document.body );
    // const blocker = document.getElementById( 'blocker' );
    // const instructions = document.getElementById( 'instructions' );

    const instructions = document.getElementById( 'instructions' );
    // const instructions = document.getElementById( 'body' );

    instructions.addEventListener( 'click', function () {
        controls.lock();
        tour_active = false;
    } );

    // controls.lock(); // lock the mouse to viewing angle

    controls.addEventListener( 'lock', function () {
        instructions.style.display = 'none';
        blocker.style.display = 'none';
    } );

    controls.addEventListener( 'unlock', function () {
        blocker.style.display = 'block';
        instructions.style.display = '';
        tour_active = false;
    } );				



    scene.add( controls.getObject() );

    const onKeyDown = function ( event ) {
        switch ( event.code ) {
            case 'ArrowUp':
            case 'KeyW':
                moveForward = true;
                break;

            case 'ArrowLeft':
            case 'KeyA':
                moveLeft = true;
                break;

            case 'ArrowDown':
            case 'KeyS':
                moveBackward = true;
                break;

            case 'ArrowRight':
            case 'KeyD':
                moveRight = true;
                break;

            case 'KeyQ':
                moveDown = true;
                break;

            case 'KeyE':
                moveUp = true;
                break;


            case 'Space':
                warp_enabled = true
                break;

        }
    };

    const onKeyUp = function ( event ) {
        switch ( event.code ) {

            case 'ArrowUp':
            case 'KeyW':
                moveForward = false;
                break;

            case 'ArrowLeft':
            case 'KeyA':
                moveLeft = false;
                break;

            case 'ArrowDown':
            case 'KeyS':
                moveBackward = false;
                break;

            case 'ArrowRight':
            case 'KeyD':
                moveRight = false;
                break;

            case 'KeyQ':
                moveDown = false;
                break;

            case 'KeyE':
                moveUp = false;
                break;

            case 'KeyL':
                stars_filter = 'galactic';
                camera.position.x = 1000;
                camera.position.y = 20000;
                camera.position.z = 1000;
                camera.lookAt( 0, 0, 0);
                reload_all_stars();
                break;

            case 'KeyG':
                camera.position.x = 1000;
                camera.position.y = 20000;
                camera.position.z = 1000;
                camera.lookAt( 0, 0, 0);
                break;

            // case 'KeyR':
            //     camera.position.x = -200;
            //     camera.position.y = 100;
            //     camera.position.z = 100;
            //     camera.lookAt( 0, 200, 100);
            //     break;

            // case 'KeyB':
            //     camera.position.x = -2;
            //     camera.position.y = 1;
            //     camera.position.z = -2;
            //     camera.lookAt( 10, 1, 10);
            //     break;

            case 'KeyP':
                camera.position.x = -10;
                camera.position.y = -2;
                camera.position.z = -6;
                // camera.position.x = 0;
                // camera.position.y = 0;
                // camera.position.z = 0;
                // // File                                sources  ra_min      ra_max      dec_min     dec_max
                // GaiaSource_376186-377043.csv.fapec  516919   61.877817   92.808166   0.008648    19.464846
                // So somewhere near ra 61.877817, dec 19.464846: Hyades + Aldebaran
                camera.lookAt( 60, 200, 44);
                break;


            case 'KeyT':
                toggle_global_sizeAttenuation()
                break;

            case 'KeyY':
                tour_active = ! tour_active
                // if (tour_active) controls.unlock();
                console.log(tour_active)
                // tour_update( camera);
                break;

            case 'Space':
                warp_enabled = false;
                break;

            case 'KeyN':
                stars_filter = 'da_hood'
                reload_all_stars();
                break;
        }
    };

    document.addEventListener( 'keydown', onKeyDown );
    document.addEventListener( 'keyup', onKeyUp );

    reload_all_stars()
}

function toggle_global_sizeAttenuation() {
    var prev_global_sizeAttenuation = global_sizeAttenuation;

    global_sizeAttenuation = ! global_sizeAttenuation;

    var existing_node_multiplier;
    if (! global_sizeAttenuation) {
        global_sizeAttenuation_multiplier = 1;
        existing_node_multiplier = global_sizeAttenuation_multiplier;
    }
    else global_sizeAttenuation_multiplier = 1;

    console.log( "global attentuation", global_sizeAttenuation);
    scene.traverse( function( node ) {
        if ( node instanceof THREE.Points ) {
            node.material.sizeAttenuation = global_sizeAttenuation;
            if (! global_sizeAttenuation) {
                node.material.size = node.material.name * global_sizeAttenuation_multiplier;
            } else {
                node.material.size = node.material.name;
            }
            node.material.needsUpdate = true;
            
        }

    } );
}

function reload_all_stars() {
    // if (stars_filter == prev_stars_filter) {
    //     console.log( 'already watching filter ' + stars_filter)
    //     return 0;
    // }
    
    // if ((stars_filter == 'galactic') && (global_sizeAttenuation == true))
    //     toggle_global_sizeAttenuation();


    // Reset scene
    scene.remove.apply(scene, scene.children);
    all_stars = {}
    total_stars_in_scene = 0
    total_cubes_in_scene = 0
    available_elements = []
    for (var i = 0; i < 100; i++) available_elements.push( i);
    // for (var i = 0; i < 2; i++) available_elements.push( i);

    // Add Sol
    add_stars_to_scene( scene, [
        [ 0, 0, 0, 1, -10],
    // [ 5, 5, 5, 0.5, -10],
    // [ 10, 20, 10, 2, -10]
    ])

    // add_cubes_to_scene( scene, [])
    // add_nebulae_to_scene( scene, [])
    
    rendered_sky_elements = []
    console.log('Full data reload should occur automatically now...')

    // rendered_sky_elements = []
    // prev_stars_filter = stars_filter;
    prev_data_set = data_set

    initial_scene_reloaded = true;
}

function load_next_sky_element() {
    // console.log( available_elements);
    var element;
    var all_stars_keys = Object.keys( all_stars)
    // console.log('DEBUG61', all_stars_keys)
    for (var index in available_elements) {
        // element = available_elements[index];
        // From now on elements will just be the numbers 0 to 99
        // so that every data set consists of 100 files
        element = index;

        if (! all_stars_keys.includes(element)) { 
            // console.log( 'Need to load element ' + element)
            // only parse 1 to save resources
            
            if (! loading_lock) {
                loadScript( scene, element);
            }
            // add_stars_to_scene( scene, all_stars[ element])
            // rendered_sky_elements.push( element)
            // return 0
        } else {
            // console.log( 'Already loaded: ' + element)
            
        }
    }
}

function load_available_sky_elements() {
    // console.log('DEBUG71', Object.keys(all_stars))
    for (var element in all_stars) {
        if ( ! rendered_sky_elements.includes(element)) { 
            // console.log( 'Need to parse element ' + element)
            // only parse 1 to save resources
            var total_stars = all_stars[ element].length;
            var num_added
            if (data_set_type == 'cubes') {
                num_added = add_cubes_to_scene( scene, all_stars[ element]);
                total_cubes_in_scene += num_added
            } else  {
                num_added = add_stars_to_scene( scene, all_stars[ element]);
                total_stars_in_scene += num_added
            } 

            // Try to allow garbage collection to kick in else we
            // use way too much memory
            all_stars[ element] = 0;
            rendered_sky_elements.push( element)
            console.log( "Added " + num_added + '/' 
                + total_stars + ' to 3D scene from element: ' + element 
                + ' (' + rendered_sky_elements.length + ' of ' + available_elements.length + '). '
                + 'Total stars/cubes in scene: ' + total_stars_in_scene+'/'+total_cubes_in_scene);
            // return 0
        } else {
            // console.log( 'Already parsed: ' + element)
            
        }
    }
}

function tour_update( camera) {
    // now.getTime();
    // requestAnimationFrame( tour_update( c2) );
    // var right_now = performance.now()

    // console.log('tour busy', tour_busy)

    var easing;
    var easing_time = 5000;
    if (tour_active && ! tour_busy && (tour_targets.length > 0)) {
        tour_started = true;
        tour_busy = true;
        var t = tour_targets[ tour_target_index];
        if (tour_stops.length == 0) {
            easing = TWEEN.Easing.Circular.InOut;


            
            tour_stops = [
                [t[0] - tour_orbit_radius, t[1], t[2]]
            ]

            /*
            Calculate a nice pseudo fly around orbit. It's not so much an actual orbit
            as it is a step-wise walk around the edges of a circle comprising pizza
            slice triangles. Therefore, flying around stars should now start to 
            make you feel hungry ;).
            */
            var orbit_step_size = 0.2;
            var xdiff, ydiff, zdiff;
            var cur_radius = tour_orbit_radius;
            for (var i = orbit_step_size; i < Math.PI * 6; i += 0.2) {
                cur_radius = tour_orbit_radius + Math.sin(i * 0.2) * 0.6 * tour_orbit_radius;
                xdiff = t[0] - Math.cos(i) * cur_radius;
                ydiff = t[1] + Math.sin(i * 0.4) * 0.8 * cur_radius;
                zdiff = t[2] + Math.sin(i) * cur_radius;
                tour_stops.push( [xdiff, ydiff, zdiff])
            }
            /*
            // Go around the object along the edges of a cube. Boring and lame.
            tour_stops = [
                [t[0] - tour_orbit_radius, t[1] - tour_orbit_radius, t[2]  - tour_orbit_radius],
                [t[0] + tour_orbit_radius, t[1] - tour_orbit_radius, t[2]  - tour_orbit_radius],
                [t[0] + tour_orbit_radius, t[1] + tour_orbit_radius, t[2]  - tour_orbit_radius],
                [t[0] + tour_orbit_radius, t[1] + tour_orbit_radius, t[2]  + tour_orbit_radius],
                [t[0] - tour_orbit_radius, t[1] + tour_orbit_radius, t[2]  + tour_orbit_radius],
                [t[0] - tour_orbit_radius, t[1] + tour_orbit_radius, t[2]  - tour_orbit_radius],
                [t[0] - tour_orbit_radius, t[1] - tour_orbit_radius, t[2]  - tour_orbit_radius],
            ]
            */

            // Pan camera to new object smoothly
            tour_object_panning = true
            perspectiveCamera.getWorldDirection( camera_vector );
            var angle_from = { 
                x: camera.position.x + camera_vector.x * 1000, 
                y: camera.position.y + camera_vector.y * 1000, 
                z: camera.position.z + camera_vector.z * 1000} 

            var angle_to = { x : t[0], y : t[1], z : t[2] };

            easing = TWEEN.Easing.Linear.None;
            // easing = TWEEN.Easing.Sinusoidal.InOut
            // console.log('ALERT1: start panning')
            var tween = new TWEEN.Tween(angle_from)
            .to( angle_to, 2000)
            .easing( easing)
            // .easing( TWEEN.Easing.Cubic.InOut)
            // .easing( TWEEN.Easing.Linear.None)            
            .onUpdate( function () {
                // console.log( 'ALERT4', camera.position.x, from.x)
                // camera.position.x = this.x;
                // camera.position.set( from.x, from.y, from.z);
                camera.lookAt( angle_from.x, angle_from.y, angle_from.z);
            })
            .onComplete( function () {
                // camera.lookAt( t[0], t[1], t[2]);
                // tour_busy = false
                tour_object_panning = false;
            })
            .start();

        } else {
            // Go faster and linear for the semi-circular orbital pizza slices calculated above
            easing = TWEEN.Easing.Linear.None;
            easing_time = 500; // ms

            // easing = TWEEN.Easing.Sinusoidal.InOut; // Was used for cube lookaround

        }
        
        var from = { x: camera.position.x, y: camera.position.y, z: camera.position.z } 

        var ts = tour_stops.shift();
        // console.log('ALERT2', tour_busy, tour_target_index, tour_stops.length, ts)
        
        // start the tween for the camera position
        var to = { x : ts[0], y : ts[1], z : ts[2] };
        var tween = new TWEEN.Tween(from)
            .to( to, easing_time)
            // .easing( TWEEN.Easing.Cubic.InOut)
            .easing( easing)            
            .onUpdate( function () {
                // console.log( 'ALERT4', camera.position.x, from.x)
                // camera.position.x = this.x;
                camera.position.set( from.x, from.y, from.z);
                if (!tour_object_panning)
                    camera.lookAt( t[0], t[1], t[2]);
            })
            .onComplete( function () {
                camera.lookAt( t[0], t[1], t[2]);
                tour_busy = false
            })
            .start();





        // start the tween for the camera viewing angle
        // TODO

        // tour_index += 1;
        if (tour_stops.length == 0) {
            // Move to next object in tour_targets
            tour_target_index += 1;
            if (tour_target_index == tour_targets.length) {
                // Make tour ready for reuse:
                tour_active = false;
                tour_target_index = 0;
            }
            // tour_busy = false;
            // tour_index = 0; // Will create next tour_stops[] for next tour_targets item.
        }
    }
    return 0


}

function onWindowResize() {

    const aspect = window.innerWidth / window.innerHeight;

    perspectiveCamera.aspect = aspect;
    perspectiveCamera.updateProjectionMatrix();

    orthographicCamera.left = - frustumSize * aspect / 2;
    orthographicCamera.right = frustumSize * aspect / 2;
    orthographicCamera.top = frustumSize / 2;
    orthographicCamera.bottom = - frustumSize / 2;
    orthographicCamera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );

    // controls.handleResize(); // not sure what this is/was supposed to do?

}

function animate() {
    requestAnimationFrame( animate );

    const time = performance.now();

    camera = perspectiveCamera;
    
    perspectiveCamera.getWorldDirection( camera_vector );

    if (tour_active && !tour_busy) {
        tour_update( camera);
    }
    if (tour_busy) {
        TWEEN.update();
    }


    stats.update();
    // if ( controls.isLocked === true ) {

    // raycaster.ray.origin.copy( controls.getObject().position );
        // raycaster.ray.origin.y -= 10;

        // const intersections = raycaster.intersectObjects( objects, false );

        // const onObject = intersections.length > 0;

    // const delta = ( time - prevTime ) / 1000;
    var delta = 10 / 1000;

    if (warp_enabled) { 
        warp_speed += 0.1;
        if (warp_speed > 10) warp_speed = 9.9;
    } else {
        if (warp_speed > 1) warp_speed -= 0.1;
        if (warp_speed < 1) warp_speed = 1;
    }
    delta = delta * (warp_speed ** 1.5)
    // delta = delta * ((warp_speed/3) ** 2)
    // delta = delta * (warp_speed ** 1.5)
    // console.log( delta)
    

    // velocity.x -= velocity.x * speed_multiplier * delta;
    // velocity.y -= velocity.y * speed_multiplier * delta;
    // velocity.z -= velocity.z * speed_multiplier * delta;

    // velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

    direction.z = Number( moveForward ) - Number( moveBackward );
    if (moveUp || moveDown) direction.y = Number( moveUp) - Number( moveDown );
    else direction.y = camera_vector.y * (Number( moveForward ) - Number( moveBackward ));
    direction.x = Number( moveRight ) - Number( moveLeft );
    direction.normalize(); // this ensures consistent movements in all directions

    if ( moveForward || moveBackward ) velocity.z -= direction.z * 400.0 * delta;
    else velocity.z -= velocity.z * speed_multiplier * delta;
    if ( moveForward || moveBackward || moveUp || moveDown) velocity.y -= direction.y * 400.0 * delta;
    else velocity.y -= velocity.y * speed_multiplier * delta;
    if ( moveLeft || moveRight ) velocity.x -= direction.x * 400.0 * delta;
    else velocity.x -= velocity.x * speed_multiplier * delta;




    // if ( (direction.x != 0) || (direction.y != 0) || (direction.z != 0)) {
    // 	console.log( 'camera: ', camera_vector)
    // 	// console.log( 'direction: ', direction)
    // }
    // if ( (velocity.x != 0) || (velocity.y != 0) || (velocity.z != 0)) {
    // 	console.log( 'camera: ', camera_vector)
    // 	// console.log( 'velocity: ', velocity )
    // }
    // if ( onObject === true ) {

    // 	velocity.y = Math.max( 0, velocity.y );
    // 	canJump = true;

    // }
    var max_velocity = 300;
    if (velocity.x > max_velocity) velocity.x = max_velocity;
    if (velocity.y > max_velocity) velocity.y = max_velocity;
    if (velocity.z > max_velocity) velocity.z = max_velocity;
    if (velocity.x < -max_velocity) velocity.x = -max_velocity;
    if (velocity.y < -max_velocity) velocity.y = -max_velocity;
    if (velocity.z < -max_velocity) velocity.z = -max_velocity;

    // if (
    // 	(velocity.x * delta > 10) ||
    // 	(velocity.y * delta > 10) ||
    // 	(velocity.z * delta > 10)) {
    // 		console.log( 'velos', velocity.x * delta, velocity.y * delta, velocity.z * delta);
    // 		console.log( 'delta', delta);

    // 	}
    controls.moveRight( - velocity.x * delta );
    controls.moveUp( - velocity.y * delta );
    controls.moveForward( - velocity.z * delta );
    // controls.moveUp( - velocity.y * delta );

    // controls.getObject().position.y += ( velocity.y * delta ); // new behavior

    // if ( controls.getObject().position.y < 10 ) {

    // 	velocity.y = 0;
    // 	controls.getObject().position.y = 10;

    // 	canJump = true;

    // }

    // }

    prevTime = time;


    // console.log('render now')
    renderer.render( scene, camera );

    var dist = Math.sqrt( camera.position.x**2 + camera.position.y**2 + camera.position.z**2)

    var deg = Math.asin( camera.position.z / dist);
    var deg_degrees = deg * 180 / Math.PI;
    var deg_mins = (deg_degrees - Math.floor( deg_degrees)) * 60;

    
    var RA = Math.atan2( camera.position.y, camera.position.x);
    if (RA < 0) RA = Math.PI * 2 + RA;
    var RA_degrees = RA * 180 / Math.PI;
    var RA_hours = Math.floor( RA_degrees / 15)
    var RA_mins = ((RA_degrees - RA_hours * 15) / 15 * 60)
    var RA_secs = (RA_mins - Math.floor( RA_mins)) * 60;

    document.getElementById('statusline').innerText = 
    '[ Camera data ]\n'
        + 'Position (x,y,z) in ly:\n  ' 
        + camera.position.x.toFixed(2) + ', '
        + camera.position.y.toFixed(2) + ', ' 
        + camera.position.z.toFixed(2) 
        + '\n'
        + 'Earth/Sol distance:\n  '
        + dist.toFixed(2) + ' ly =~ '
        + (dist/lightyear_p_parsec).toFixed(2) + ' pc '
        + '\n'
        + 'Earth/Sol coords:\n'
        + '  RA: ' + parseInt(RA_hours) + 'h' 
        + parseInt(RA_mins) + 'm ' 
        + RA_secs.toFixed(1) + 's'
        + '\n'
        + '  dec: ' + (deg_degrees > 0 ? '+':'') + parseInt(deg_degrees)
        + '°'+ deg_mins.toFixed(1) + "′"
        + '\n'
        + 'Camera angle vector (x,y,z):\n  '
        + camera_vector.x.toFixed(2) + ', ' 
        + camera_vector.y.toFixed(2) + ', ' 
        + camera_vector.z.toFixed(2)
        + '\nTotal stars/cubes in scene: ' 
        + '  ' + total_stars_in_scene+'/'+total_cubes_in_scene
        
        ;



}

function render() {

    const camera = ( params.orthographicCamera ) ? orthographicCamera : perspectiveCamera;
    
    renderer.render( scene, camera );

}

// Now you can get back to yer silly tidy XML based indentation, hah!
		</script>
	</body>
</html>
