<!DOCTYPE html>
<html lang="en">
	<head>
		<title>GAIA-Web 3D Starfield v0.1</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="three.js/main.css">
		<style>
			body {
				background-color: #ccc;
				color: #000;
			}
			a {
				color: #f00;
			}
			#statusline {
				position: absolute;
                left: 0px;
                bottom: 0px;
				width: auto;
				height: auto;
				color: greenyellow;
				background-color: rgba(0,0,0,0.4);

				display: flex;
				flex-direction: row;
				justify-content: left;
				/* align-items: center; */

				text-align: left;
                margin: 0;
                padding: 5px;
                line-height: 100%;
				font-size: 12px;
				/* cursor: pointer; */
				border: 1px solid green;

			}
			#blocker {
				position: absolute;
				width: 100%;
				height: 100%;
				color: white;
				background-color: rgba(0,0,0,0.1);
			}

			#instructions {
				width: 100%;
				height: 100%;

				display: flex;
				flex-direction: column;
				justify-content: left;
				align-items: left;

                line-height: 100%;
				text-align: left;
				font-size: 12px;
				cursor: pointer;
				border: 3px solid white;
			}			
		</style>
	</head>

	<body>
		<div id="blocker">
			<div id="instructions">
				<p style="font-size:16px">
<pre>



Welcome to Gaia-web, where you can fly through the 
stars like the USS Enterprise :)

Where pressing space finally gets you into space :)

Please be patient as star data is loaded in the background.

   Click here to start ...
</pre>
				</p>
				<p> Keyboard shortcuts: <br/>
					Move: WASDQE<br/>
					Warp: Space<br/>
					Look: Mouse<br/>
					Toggle distance dimming: T<br/>
                    Back to Sol: B<br/>
                    Galactic overview: G<br/>
                    Planet Earth/Sol/Origin: P<br/>
                    Reload all star data for galactic overview: L<br/>
                    Reload all star data for Sol neighbourhood:Planet Earth/Sol/Origin: N<br/>
				</p>
			</div>
		</div>
		<pre id="statusline"></pre>
		<!-- 
		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - trackball controls<br />
			MOVE mouse &amp; press LEFT/A: rotate, MIDDLE/S: zoom, RIGHT/D: pan
		</div>
			<script type="text/javascript" src="./stars-test-01.js"></script>
    		<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
		 -->
		
		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="./libs/es-module-shims.js"></script>
        <script src="./libs/tween.umd.js"></script>


		<script type="importmap">
			{
				"imports": {
					"three": "./three.js/build/three.module.js",
					"three/addons/": "./three.js/jsm/",
					"local-data/": "./data/"
				}
			}
		</script>

		<!-- The main index of all sky patch elements, which basically based on this file:
            http://cdn.gea.esac.esa.int/Gaia/gdr3/gaia_source/_MD5SUM.txt
         -->
        <script type="text/javascript" src="data/gaia-web-sky-elements.js"></script>
        <script type="module">
// Uhm yeah the HTML ain't gonna dictate our indentation. Who does it think it is!?!?
import * as THREE from 'three';

import Stats from 'three/addons/libs/stats.module.js';
import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

// import { TrackballControls } from 'three/addons/controls/TrackballControls.js';

import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

let moveForward = false;
let moveBackward = false;
let moveLeft = false;
let moveRight = false;
let moveUp = false;
let moveDown = false;
let canJump = false;
let warp_speed = 1;
let warp_enabled = false;
let global_sizeAttenuation = true;
let global_sizeAttenuation_multiplier = 1;

let stars_filter = 'da_hood';
// let stars_filter = 'galactic';
let prev_stars_filter = ''; // Set to empty to force reload @ reload_all_stars() call

let tour_active = false;
let tour_speed = 0;
let tour_target_arrived = false;
let tour_time_at_target = 0;
let tour_prev_update = 0;
let tour_orbit_radius = 10; //ly
let tour_targets = [
    [ 62, 130,   50],
    [515, 345, 1055]
];

let tour_orbit_angle;
let tour_orbit_dec = 0;
let tour_orbit_start_x;
let tour_orbit_start_y;
let tour_orbit_start_z;
let tour_orbit_insertion_distance;
let tour_orbit_insertion_speed;
let tour_orbit_target;
let tour_started = false;
let tour_stops = [];
let tour_target_index = 0;
let tour_busy = false;
let tour_object_panning = true;

let prevTime = performance.now();
const velocity = new THREE.Vector3();
const direction = new THREE.Vector3();
const vertex = new THREE.Vector3();
const camera_vector = new THREE.Vector3();
const color = new THREE.Color();
let initial_scene_reloaded = false;


const sprite = new THREE.TextureLoader().load( 'three.js/textures/sprites/disc.png' );

let camera, perspectiveCamera, orthographicCamera, controls, scene, renderer, stats;

const params = {
    orthographicCamera: false,
    'option 1': false,
    'option 2': true
};

const frustumSize = 400;
var star_max_dist = 10**5;
var star_max_dist = 10**3;
var all_stars = {};
var rendered_sky_elements = [];

var loading_lock = false;

var speed = 0
var speed_multiplier = 10.0	// 5.0
var lightyear_p_parsec = 3.261563777

init();
animate();


function add_stars_to_scene( scene, star_coords) {
    const positions = [];
    const size_buckets = {};
    
    var colors = [];
    var color_array = [];
    var veff_color = 0;
    var Wavelength = 0;
    var Red = 0;
    var Green = 0;
    var Blue = 0;
    var Teff = 0;
    const color = new THREE.Color();

    // console.log( star_coords.length);
    // // console.log( star_colors.length);
    // console.log( star_coords[star_coords.length-1]);

    var apparent_magnitude = 10;
    var dimming_factor = 1;
    var temperature = 0;
    var red, green, blue;
    var distance;
    var abs_magnitude;
    var x, y, z;
    var temperature_fudge_factor = 1.4;

    for ( var i = 0; i < star_coords.length; i += 1) {

        x = star_coords[i][0];
        y = star_coords[i][1];
        z = star_coords[i][2];
        veff_color = star_coords[i][3];
        abs_magnitude = star_coords[i][4];

        // TODO: Add filtering based on GUI options selected
        distance = Math.sqrt( x**2 + y**2 + z**2)
        
        // if (distance > 2500) continue;
        if ( stars_filter == 'da_hood')
            if (distance > 2000) continue;

        if ( stars_filter == 'galactic')
            if ((distance > 70000) || (abs_magnitude > -3)) continue;
        // if ((distance < 3000) || (distance > 70000) || (abs_magnitude > -5)) continue;
        // if (distance < 2000) continue;

        /*
        Quick absolute magnitude bucket check from a single source file
        3 -9
        9 -8
        34 -7
        111 -6
        459 -5
        1516 -4
        4407 -3
        9748 -2
        17694 -1
        30381 -0
        40426 0
        43501 1
        40873 2
        36897 3
        31345 4
        24082 5
        14950 6
        7328 7
        2546 8
        589 9
        72 10
        5 11
        */

        // Aim to make the stars between 0.2 and 3 in size to ensure reasonable
        // spread over the absolute magitude bucket sized above
        var star_size = parseInt( 20 - (parseInt(abs_magnitude) + 10)) / 5
        if (star_size > 3) star_size = 3;
        if (star_size < 0.2) star_size = 0.2;

        // initialize bucket if needed:
        if ( ! (star_size in size_buckets)) {
            // console.log( 'Need to create bucket: ' + star_size)
            size_buckets[ star_size] = {
                positions: [],
                colors: []
            }
        }
        
        size_buckets[ star_size]['positions'].push( x, y, z);
        if (distance > star_max_dist) star_max_dist = distance;


        // Dim the brightness of the RGB values further according to magnitude
        dimming_factor = ((900 - ((abs_magnitude+8)**2)) / 900)
        
        if (dimming_factor > 1) dimming_factor = 1;
        if (dimming_factor < 0.1) dimming_factor = 0.1;

        if (veff_color == 0) { color.setRGB( 1, 1, 1) }
        else {
            // νeff, in μm−1
            // veff -> rgb: https://stackoverflow.com/questions/1472514/convert-light-frequency-to-rgb
            // Teff -> rgb: https://www.npmjs.com/package/color-temperature?activeTab=code

            // Wavelength = 1 / (veff_color * 10**-3)

            // For some reason 90% of stars come out red, so apply a fudge
            // factor. TODO: Find out how grown-ups calculate it properly
            Teff = 2.8977719 * veff_color * 1000 * temperature_fudge_factor

            // Calculate RGB values according to Teff 
            temperature = Teff / 100.0;

            // Red
            if (temperature <= 66.0) {
                red = 255;
            } else {
                red = temperature - 60.0;
                red = 329.698727446 * Math.pow(red, -0.1332047592);
                if (red < 0) red = 0;
                if (red > 255) red = 255;
            }

            /* Calculate green */
            if (temperature <= 66.0) {
                green = temperature;
                green = 99.4708025861 * Math.log(green) - 161.1195681661;
                if (green < 0) green = 0;
                if (green > 255) green = 255;
            } else {
                green = temperature - 60.0;
                green = 288.1221695283 * Math.pow(green, -0.0755148492);
                if (green < 0) green = 0;
                if (green > 255) green = 255;
            }

            /* Calculate blue */
            if (temperature >= 66.0) {
                blue = 255;
            } else {
                if (temperature <= 19.0) {
                    blue = 0;
                } else {
                    blue = temperature - 10;
                    blue = 138.5177312231 * Math.log(blue) - 305.0447927307;
                    if (blue < 0) blue = 0;
                    if (blue > 255) blue = 255;
                }
            }

            // console.log( Wavelength)
            // if (i % 100000 == 0) { 
            // 	console.log( apparent_magnitude, dimming_factor, Teff, red, green, blue) 
            // 	console.log( red*dimming_factor/255, green*dimming_factor/255, blue*dimming_factor/255);
            // }
            color.setRGB( red*dimming_factor/255, green*dimming_factor/255, blue*dimming_factor/255);
        }
        size_buckets[ star_size]['colors'].push( color.r, color.g, color.b );
    };

    // add all computed buckets to the scene
    var stars_geometry;
    var total_added = 0;
    // console.log( 'size bucket keys: ', Object.keys(size_buckets))
    for (const [size, bucket] of Object.entries(size_buckets)) {
        // console.log(size, bucket);
    
        stars_geometry = new THREE.BufferGeometry();
        stars_geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( bucket['positions'], 3 ) );
        stars_geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( bucket['colors'], 3 ) );

        /*
        Since custom properties apparently don't stick, we instead 
        appropiate .name for the original size, as we need to 
        increase/descrease size on the fly when toggling 
        the .sizeAttenuation property.
        */
        const point_material = new THREE.PointsMaterial( { 
            size: size * global_sizeAttenuation_multiplier, 
            name: size,
            sizeAttenuation: global_sizeAttenuation, map: sprite, 
            alphaTest: 0.5, transparent: false, vertexColors: true 
        } );

        var points = new THREE.Points( stars_geometry, point_material );
        scene.add( points );
        total_added += bucket['positions'].length;
        // console.log('DEBUG1 Added size/# new stars: ', size, bucket['positions'].length)
    }
    // console.log('DEBUG1', star_max_dist)
    // console.log('Added # new stars to scene: ', total_added);

    const axesHelper = new THREE.AxesHelper( star_max_dist );
    scene.add( axesHelper );
    return total_added;
}

// Based on SO answers pointing to most recent JS standards and usage. What do I know.
function loadScript (scene, sky_element, async = false, type = "text/javascript") {
	var filename = './data/' + sky_element + '.js';
	var FILE_URL = filename;

	if (loading_lock) {
		// Try again next time
		// return 0
	}
	loading_lock = true;

    return new Promise((resolve, reject) => {
        try {
            const scriptEle = document.createElement("script");
            scriptEle.type = type;
            scriptEle.async = async;
            scriptEle.src = FILE_URL;

            scriptEle.addEventListener("load", (ev) => {
                resolve({ status: true });
                // Add the data to all_stars[] where it will be checked and read from later
				all_stars[sky_element] = stars;
				loading_lock = false;

                var num_loaded = Object.keys( all_stars).length;
                var total = available_elements.length
				console.log("Parsed file " + num_loaded + ' of ' + total
                    + ' (' + sky_element + '): #'
                    + all_stars[sky_element].length + " stars' data loaded.");

				// add_stars_to_scene( scene, stars)
				// console.log('DEBUG3', star_max_dist)
				// console.log('DEBUG32', Object.keys(all_stars))
				// console.log('DEBUG33 loading lock', loading_lock)
				load_next_sky_element()
            });

            scriptEle.addEventListener("error", (ev) => {
                reject({
                    status: false,
                    message: `Failed to load the script ` + FILE_URL
                });
				loading_lock = false;
            });

            document.body.appendChild(scriptEle);
        } catch (error) {
            reject(error);
			loading_lock = false;
        }
    });
};


function init() {

    const aspect = window.innerWidth / window.innerHeight;

    scene = new THREE.Scene();

    var far_away = 10**6
    perspectiveCamera = new THREE.PerspectiveCamera( 60, aspect, 1, far_away );
    perspectiveCamera.position.x = -200;
    perspectiveCamera.position.y = 100
    perspectiveCamera.position.z = 100;

    perspectiveCamera.lookAt( 200, 100, 100 );

    orthographicCamera = new THREE.OrthographicCamera( frustumSize * aspect / - 2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, 1, star_max_dist );
    // orthographicCamera.position.x =
    // orthographicCamera.position.y =
    // orthographicCamera.position.z = 10000;

    // world

    // scene.background = new THREE.Color( 0xcccccc );
    // scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );

    // const geometry = new THREE.CylinderGeometry( 0, 10, 30, 4, 1 );
    // const material = new THREE.MeshPhongMaterial( { color: 0xffffff, flatShading: true } );

    // for ( let i = 0; i < 500; i ++ ) {

    // 	const mesh = new THREE.Mesh( geometry, material );
    // 	mesh.position.x = ( Math.random() - 0.5 ) * 1000;
    // 	mesh.position.y = ( Math.random() - 0.5 ) * 1000;
    // 	mesh.position.z = ( Math.random() - 0.5 ) * 1000;
    // 	mesh.updateMatrix();
    // 	mesh.matrixAutoUpdate = false;
    // 	scene.add( mesh );

    // }

    // // lights

    // const dirLight1 = new THREE.DirectionalLight( 0xffffff );
    // dirLight1.position.set( 1, 1, 1 );
    // scene.add( dirLight1 );

    // const dirLight2 = new THREE.DirectionalLight( 0x002288 );
    // dirLight2.position.set( - 1, - 1, - 1 );
    // scene.add( dirLight2 );

    // const ambientLight = new THREE.AmbientLight( 0x222222 );
    // scene.add( ambientLight );

    // renderer

    renderer = new THREE.WebGLRenderer( { antialias: true } );
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );

    stats = new Stats();
    document.body.appendChild( stats.dom );


    // load_file('7gaiasources');
    // loadJS( scene, '7gaiasources', false);
    // loadJS( scene, 'GaiaSource_005264-006601', false);
    // loadJS( scene, 'GaiaSource_003112-005263', false);


    // console.log('DEBUG2', star_max_dist)
    // console.log('DEBUG2', Object.keys(all_stars))

    const axesHelper = new THREE.AxesHelper( star_max_dist );
    scene.add( axesHelper );

    var rendered_sky_elements = []

    const interval1 = setInterval(function() {
        // method to be executed;
        // console.log( 'DEBUG4: ', Date())
        load_available_sky_elements()
    }, 2000);

    const interval2 = setInterval(function() {
        // method to be executed;
        // console.log( 'DEBUG5: ', Date())
        // console.log('DEBUG51 loading lock', loading_lock)

        if (! loading_lock && initial_scene_reloaded) load_next_sky_element();
    }, 2000);

    const gui = new GUI();

    // TODO: build gui option for each params option

    gui.add( params, 'option 1' ).name( 'Disable distance dimming (sizeAttentuation)' ).onChange( function ( value ) {

        // controls.dispose();

        // createControls( value ? orthographicCamera : perspectiveCamera );
        // alert('hi')
        // To set items still loading in right
        global_sizeAttenuation = value ? false : true;
        // console.log( "global attentuation", global_sizeAttenuation);

        scene.traverse( function( node ) {
            if ( node instanceof THREE.Points ) {
                // console.log( "toggling attentuation", node.material.sizeAttenuation)
                // insert your code here, for example:
                // console.log( node);
                node.material.sizeAttenuation = global_sizeAttenuation;
                node.material.needsUpdate = true;
            }

        } );
    } );

// function toggle_global_sizeAttenuation

    gui.add( params, 'orthographicCamera' ).name( 'use orthographic' ).onChange( function ( value ) {

        // controls.dispose();

        // createControls( value ? orthographicCamera : perspectiveCamera );

    } );

    //

    window.addEventListener( 'resize', onWindowResize );

    // createControls( perspectiveCamera );



    // camera = perspectiveCamera

    controls = new PointerLockControls( perspectiveCamera, document.body );
    // const blocker = document.getElementById( 'blocker' );
    // const instructions = document.getElementById( 'instructions' );

    const instructions = document.getElementById( 'instructions' );
    // const instructions = document.getElementById( 'body' );

    instructions.addEventListener( 'click', function () {
        controls.lock();
        tour_active = false;
    } );

    // controls.lock(); // lock the mouse to viewing angle

    controls.addEventListener( 'lock', function () {
        instructions.style.display = 'none';
        blocker.style.display = 'none';
    } );

    controls.addEventListener( 'unlock', function () {
        blocker.style.display = 'block';
        instructions.style.display = '';
        tour_active = false;
    } );				



    scene.add( controls.getObject() );

    const onKeyDown = function ( event ) {
        switch ( event.code ) {
            case 'ArrowUp':
            case 'KeyW':
                moveForward = true;
                break;

            case 'ArrowLeft':
            case 'KeyA':
                moveLeft = true;
                break;

            case 'ArrowDown':
            case 'KeyS':
                moveBackward = true;
                break;

            case 'ArrowRight':
            case 'KeyD':
                moveRight = true;
                break;

            case 'KeyQ':
                moveDown = true;
                break;

            case 'KeyE':
                moveUp = true;
                break;


            case 'Space':
                warp_enabled = true
                break;

        }
    };

    const onKeyUp = function ( event ) {
        switch ( event.code ) {

            case 'ArrowUp':
            case 'KeyW':
                moveForward = false;
                break;

            case 'ArrowLeft':
            case 'KeyA':
                moveLeft = false;
                break;

            case 'ArrowDown':
            case 'KeyS':
                moveBackward = false;
                break;

            case 'ArrowRight':
            case 'KeyD':
                moveRight = false;
                break;

            case 'KeyQ':
                moveDown = false;
                break;

            case 'KeyE':
                moveUp = false;
                break;

            case 'KeyL':
                stars_filter = 'galactic';
                camera.position.x = 1000;
                camera.position.y = 20000;
                camera.position.z = 1000;
                camera.lookAt( 0, 0, 0);
                reload_all_stars();
                break;

            case 'KeyG':
                camera.position.x = 1000;
                camera.position.y = 20000;
                camera.position.z = 1000;
                camera.lookAt( 0, 0, 0);
                break;

            // case 'KeyR':
            //     camera.position.x = -200;
            //     camera.position.y = 100;
            //     camera.position.z = 100;
            //     camera.lookAt( 0, 200, 100);
            //     break;

            // case 'KeyB':
            //     camera.position.x = -2;
            //     camera.position.y = 1;
            //     camera.position.z = -2;
            //     camera.lookAt( 10, 1, 10);
            //     break;

            case 'KeyP':
                camera.position.x = -10;
                camera.position.y = -2;
                camera.position.z = -6;
                // camera.position.x = 0;
                // camera.position.y = 0;
                // camera.position.z = 0;
                // // File                                sources  ra_min      ra_max      dec_min     dec_max
                // GaiaSource_376186-377043.csv.fapec  516919   61.877817   92.808166   0.008648    19.464846
                // So somewhere near ra 61.877817, dec 19.464846: Hyades + Aldebaran
                camera.lookAt( 60, 200, 44);
                break;


            case 'KeyT':
                toggle_global_sizeAttenuation()
                break;

            case 'KeyY':
                tour_active = ! tour_active
                // if (tour_active) controls.unlock();
                console.log(tour_active)
                // tour_update( camera);
                break;

            case 'Space':
                warp_enabled = false;
                break;

            case 'KeyN':
                stars_filter = 'da_hood'
                reload_all_stars();
                break;
        }
    };

    document.addEventListener( 'keydown', onKeyDown );
    document.addEventListener( 'keyup', onKeyUp );

    reload_all_stars()
}

function toggle_global_sizeAttenuation() {
    var prev_global_sizeAttenuation = global_sizeAttenuation;

    global_sizeAttenuation = ! global_sizeAttenuation;

    var existing_node_multiplier;
    if (! global_sizeAttenuation) {
        global_sizeAttenuation_multiplier = 1;
        existing_node_multiplier = global_sizeAttenuation_multiplier;
    }
    else global_sizeAttenuation_multiplier = 1;

    console.log( "global attentuation", global_sizeAttenuation);
    scene.traverse( function( node ) {
        if ( node instanceof THREE.Points ) {
            node.material.sizeAttenuation = global_sizeAttenuation;
            if (! global_sizeAttenuation) {
                node.material.size = node.material.name * global_sizeAttenuation_multiplier;
            } else {
                node.material.size = node.material.name;
            }
            node.material.needsUpdate = true;
            
        }

    } );
}

function reload_all_stars() {
    if (stars_filter == prev_stars_filter) {
        console.log( 'already watching filter ' + stars_filter)
        return 0;
    }
    
    if ((stars_filter == 'galactic') && (global_sizeAttenuation == true))
        toggle_global_sizeAttenuation();

    // Reset scene
    scene.remove.apply(scene, scene.children);
    all_stars = {}

    // Add Sol
    add_stars_to_scene( scene, [[ 0, 0, 0, 1, -10]])
    
    rendered_sky_elements = []
    console.log('Full data reload should occur automatically now...')

    // rendered_sky_elements = []
    prev_stars_filter = stars_filter;
    initial_scene_reloaded = true;
}

function load_next_sky_element() {
    // console.log( available_elements);
    var element;
    var all_stars_keys = Object.keys( all_stars)
    // console.log('DEBUG61', all_stars_keys)
    for (var index in available_elements) {
        element = available_elements[index];

        if (! all_stars_keys.includes(element)) { 
            // console.log( 'Need to load element ' + element)
            // only parse 1 to save resources
            
            if (! loading_lock) {
                loadScript( scene, element);
            }
            // add_stars_to_scene( scene, all_stars[ element])
            // rendered_sky_elements.push( element)
            // return 0
        } else {
            // console.log( 'Already loaded: ' + element)
            
        }
    }
}

function load_available_sky_elements() {
    // console.log('DEBUG71', Object.keys(all_stars))
    for (var element in all_stars) {
        if ( ! rendered_sky_elements.includes(element)) { 
            // console.log( 'Need to parse element ' + element)
            // only parse 1 to save resources
            var total_stars = all_stars[ element].length;
            var num_added = add_stars_to_scene( scene, all_stars[ element])

            // Try to allow garbage collection to kick in else we
            // use way too much memory
            all_stars[ element] = 0;
            rendered_sky_elements.push( element)
            console.log("Added " + num_added + '/' + total_stars + ' to 3D scene from element: '
                    + element + ' (' + rendered_sky_elements.length + ' of ' + available_elements.length + ')');
            // return 0
        } else {
            // console.log( 'Already parsed: ' + element)
            
        }
    }
}

function tour_update( camera) {
    // now.getTime();
    // requestAnimationFrame( tour_update( c2) );
    // var right_now = performance.now()

    console.log('ALERT1')

    var easing;
    if (tour_active && ! tour_busy && (tour_targets.length > 0)) {
        tour_started = true;
        tour_busy = true;
        var t = tour_targets[ tour_target_index];
        if (tour_stops.length == 0) {
            easing = TWEEN.Easing.Circular.InOut;

            tour_stops = [
                [t[0] - tour_orbit_radius, t[1] - tour_orbit_radius, t[2]  - tour_orbit_radius],
                [t[0] + tour_orbit_radius, t[1] - tour_orbit_radius, t[2]  - tour_orbit_radius],
                [t[0] + tour_orbit_radius, t[1] + tour_orbit_radius, t[2]  - tour_orbit_radius],
                [t[0] + tour_orbit_radius, t[1] + tour_orbit_radius, t[2]  + tour_orbit_radius],
                [t[0] - tour_orbit_radius, t[1] + tour_orbit_radius, t[2]  + tour_orbit_radius],
                [t[0] - tour_orbit_radius, t[1] + tour_orbit_radius, t[2]  - tour_orbit_radius],
                [t[0] - tour_orbit_radius, t[1] - tour_orbit_radius, t[2]  - tour_orbit_radius],
            ]

            // Pan camera to new object smoothly
            tour_object_panning = true
            perspectiveCamera.getWorldDirection( camera_vector );
            var angle_from = { 
                x: camera.position.x + camera_vector.x * 1000, 
                y: camera.position.y + camera_vector.y * 1000, 
                z: camera.position.z + camera_vector.z * 1000} 

            var angle_to = { x : t[0], y : t[1], z : t[2] };

            var tween = new TWEEN.Tween(angle_from)
            .to( angle_to, 2000)
            .easing( TWEEN.Easing.Cubic.InOut)
            // .easing( TWEEN.Easing.Linear.None)
            .onUpdate( function () {
                // console.log( 'ALERT4', camera.position.x, from.x)
                // camera.position.x = this.x;
                // camera.position.set( from.x, from.y, from.z);
                camera.lookAt( angle_from.x, angle_from.y, angle_from.z);
            })
            .onComplete( function () {
                // camera.lookAt( t[0], t[1], t[2]);
                // tour_busy = false
                tour_object_panning = false;
            })
            .start();

        } else {
            // easing = TWEEN.Easing.Linear.None;
            easing = TWEEN.Easing.Sinusoidal.InOut

        }
        
        var from = { x: camera.position.x, y: camera.position.y, z: camera.position.z } 

        var ts = tour_stops.shift();
        var to = { x : ts[0], y : ts[1], z : ts[2] };
        console.log('ALERT2', tour_target_index, ts)
        
        // start the tween for the camera position
        var tween = new TWEEN.Tween(from)
            .to( to, 5000)
            // .easing( TWEEN.Easing.Cubic.InOut)
            .easing( easing)            
            .onUpdate( function () {
                // console.log( 'ALERT4', camera.position.x, from.x)
                // camera.position.x = this.x;
                camera.position.set( from.x, from.y, from.z);
                if (!tour_object_panning)
                    camera.lookAt( t[0], t[1], t[2]);
            })
            .onComplete( function () {
                camera.lookAt( t[0], t[1], t[2]);
                tour_busy = false
            })
            .start();





        // start the tween for the camera viewing angle
        // TODO

        // tour_index += 1;
        if (tour_stops.length == 0) {
            // Move to next object in tour_targets
            tour_target_index += 1;
            if (tour_target_index == tour_targets.length) {
                // Make tour ready for reuse:
                tour_active = false;
                tour_target_index = 0;
            }
            tour_busy = false;
            // tour_index = 0; // Will create next tour_stops[] for next tour_targets item.
        }
    }
    return 0


}

function onWindowResize() {

    const aspect = window.innerWidth / window.innerHeight;

    perspectiveCamera.aspect = aspect;
    perspectiveCamera.updateProjectionMatrix();

    orthographicCamera.left = - frustumSize * aspect / 2;
    orthographicCamera.right = frustumSize * aspect / 2;
    orthographicCamera.top = frustumSize / 2;
    orthographicCamera.bottom = - frustumSize / 2;
    orthographicCamera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );

    controls.handleResize();

}

function animate() {
    requestAnimationFrame( animate );

    const time = performance.now();

    camera = perspectiveCamera;
    
    perspectiveCamera.getWorldDirection( camera_vector );

    if (tour_active && !tour_busy) {
        tour_update( camera);
    }
    if (tour_busy) {
        TWEEN.update();
    }


    stats.update();
    // if ( controls.isLocked === true ) {

    // raycaster.ray.origin.copy( controls.getObject().position );
        // raycaster.ray.origin.y -= 10;

        // const intersections = raycaster.intersectObjects( objects, false );

        // const onObject = intersections.length > 0;

    // const delta = ( time - prevTime ) / 1000;
    var delta = 10 / 1000;

    if (warp_enabled) { 
        warp_speed += 0.1;
        if (warp_speed > 10) warp_speed = 9.9;
    } else {
        if (warp_speed > 1) warp_speed -= 0.1;
        if (warp_speed < 1) warp_speed = 1;
    }
    delta = delta * (warp_speed ** 2)
    // delta = delta * (warp_speed ** 1.5)
    // console.log( delta)
    

    // velocity.x -= velocity.x * speed_multiplier * delta;
    // velocity.y -= velocity.y * speed_multiplier * delta;
    // velocity.z -= velocity.z * speed_multiplier * delta;

    // velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

    direction.z = Number( moveForward ) - Number( moveBackward );
    if (moveUp || moveDown) direction.y = Number( moveUp) - Number( moveDown );
    else direction.y = camera_vector.y * (Number( moveForward ) - Number( moveBackward ));
    direction.x = Number( moveRight ) - Number( moveLeft );
    direction.normalize(); // this ensures consistent movements in all directions

    if ( moveForward || moveBackward ) velocity.z -= direction.z * 400.0 * delta;
    else velocity.z -= velocity.z * speed_multiplier * delta;
    if ( moveForward || moveBackward || moveUp || moveDown) velocity.y -= direction.y * 400.0 * delta;
    else velocity.y -= velocity.y * speed_multiplier * delta;
    if ( moveLeft || moveRight ) velocity.x -= direction.x * 400.0 * delta;
    else velocity.x -= velocity.x * speed_multiplier * delta;




    // if ( (direction.x != 0) || (direction.y != 0) || (direction.z != 0)) {
    // 	console.log( 'camera: ', camera_vector)
    // 	// console.log( 'direction: ', direction)
    // }
    // if ( (velocity.x != 0) || (velocity.y != 0) || (velocity.z != 0)) {
    // 	console.log( 'camera: ', camera_vector)
    // 	// console.log( 'velocity: ', velocity )
    // }
    // if ( onObject === true ) {

    // 	velocity.y = Math.max( 0, velocity.y );
    // 	canJump = true;

    // }
    var max_velocity = 1000;
    if (velocity.x > max_velocity) velocity.x = max_velocity;
    if (velocity.y > max_velocity) velocity.y = max_velocity;
    if (velocity.z > max_velocity) velocity.z = max_velocity;
    if (velocity.x < -max_velocity) velocity.x = -max_velocity;
    if (velocity.y < -max_velocity) velocity.y = -max_velocity;
    if (velocity.z < -max_velocity) velocity.z = -max_velocity;

    // if (
    // 	(velocity.x * delta > 10) ||
    // 	(velocity.y * delta > 10) ||
    // 	(velocity.z * delta > 10)) {
    // 		console.log( 'velos', velocity.x * delta, velocity.y * delta, velocity.z * delta);
    // 		console.log( 'delta', delta);

    // 	}
    controls.moveRight( - velocity.x * delta );
    controls.moveUp( - velocity.y * delta );
    controls.moveForward( - velocity.z * delta );
    // controls.moveUp( - velocity.y * delta );

    // controls.getObject().position.y += ( velocity.y * delta ); // new behavior

    // if ( controls.getObject().position.y < 10 ) {

    // 	velocity.y = 0;
    // 	controls.getObject().position.y = 10;

    // 	canJump = true;

    // }

    // }

    prevTime = time;


    // console.log('render now')
    renderer.render( scene, camera );

    var dist = Math.sqrt( camera.position.x**2 + camera.position.y**2 + camera.position.z**2)

    var deg = Math.asin( camera.position.z / dist);
    var deg_degrees = deg * 180 / Math.PI;
    var deg_mins = (deg_degrees - Math.floor( deg_degrees)) * 60;

    
    var RA = Math.atan2( camera.position.y, camera.position.x);
    if (RA < 0) RA = Math.PI * 2 + RA;
    var RA_degrees = RA * 180 / Math.PI;
    var RA_hours = Math.floor( RA_degrees / 15)
    var RA_mins = ((RA_degrees - RA_hours * 15) / 15 * 60)
    var RA_secs = (RA_mins - Math.floor( RA_mins)) * 60;

    document.getElementById('statusline').innerText = 
    '[ Camera data ]\n'
        + 'Position (x,y,z) in ly:\n  ' 
        + camera.position.x.toFixed(2) + ', '
        + camera.position.y.toFixed(2) + ', ' 
        + camera.position.z.toFixed(2) 
        + '\n'
        + 'Earth/Sol distance:\n  '
        + dist.toFixed(2) + ' ly =~ '
        + (dist/lightyear_p_parsec).toFixed(2) + ' pc '
        + '\n'
        + 'Earth/Sol coords:\n'
        + '  RA: ' + parseInt(RA_hours) + 'h' 
        + parseInt(RA_mins) + 'm ' 
        + RA_secs.toFixed(1) + 's'
        + '\n'
        + '  dec: ' + (deg_degrees > 0 ? '+':'') + parseInt(deg_degrees)
        + '°'+ deg_mins.toFixed(1) + "′"
        + '\n'
        + 'Camera angle vector (x,y,z):\n  '
        + camera_vector.x.toFixed(2) + ', ' 
        + camera_vector.y.toFixed(2) + ', ' 
        + camera_vector.z.toFixed(2)
        ;

}

function render() {

    const camera = ( params.orthographicCamera ) ? orthographicCamera : perspectiveCamera;
    
    renderer.render( scene, camera );

}

// Now you can get back to yer silly tidy XML based indentation, hah!
		</script>
	</body>
</html>
